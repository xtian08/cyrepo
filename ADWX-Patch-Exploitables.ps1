<#
.DESCRIPTION
  This PowerShell script is invoke windows update via PS module
.CREATED by
  Christian Mariano - NYUAD    
#>

param (
    #[bool]$RunWindowsUpdate = $false
    #[string]$RunWindowsUpdate = "no"
    [switch]$RunWindowsUpdate
)

####CODE

# Clean up old log files (older than 7 days)
$logDirectory = "C:\ProgramData\AirWatch\UnifiedAgent\Logs"
$logRetentionDays = 7
$logFiles = Get-ChildItem -Path $logDirectory -Filter "ADWX_*.log" -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-$logRetentionDays) } 
foreach ($logFile in $logFiles) {
    try {
        Remove-Item -Path $logFile.FullName -ErrorAction Stop
        Write-Output "Deleted old log file: $($logFile.FullName)"
    } catch {
        Write-Output "Failed to delete log file: $($logFile.FullName) - $_"
    }
}

# Start logging

$hostname = $env:COMPUTERNAME
# Start logging with hostname included in the log filename
$LogPath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_GSD_Patch_${hostname}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
Start-Transcript -Path $LogPath -NoClobber

# Run the whoami command and capture the output
$user = whoami

# Define known system account names
$systemAccounts = @(
    "NT AUTHORITY\SYSTEM",      # Local System
    "NT AUTHORITY\LOCAL SERVICE",  # Local Service
    "NT AUTHORITY\NETWORK SERVICE" # Network Service
)

################ Start Script ################
Write-Host "*************Check and install Dependencies*************"
$progressPreference = 'silentlyContinue'

######### Check Nuget Provider #########

# Check if NuGet provider is installed
$nugetProvider = Get-PackageProvider -ListAvailable | Where-Object {$_.Name -eq "NuGet"}

if ($nugetProvider) {
    Write-Host "NuGet provider is installed."
} else {
    Write-Host "NuGet provider is not installed."
    # Install the NuGet provider without interaction
    Install-PackageProvider -Name NuGet -Force -Confirm:$false  -ErrorAction Ignore
}

######### Check PSWindowsUpdate #########

# Check if PSWindowsUpdate module is installed
$psWindowsUpdateInstalled = Get-Module -ListAvailable -Name PSWindowsUpdate

# If the module is not installed, notify the user
if (-not $psWindowsUpdateInstalled) {
    Write-Host "PSWindowsUpdate module is not installed."
        # Set the NuGet package provider to trust all repositories
    #Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
    Install-Module -Name PSWindowsUpdate -Repository PSGallery -Force -AllowClobber -SkipPublisherCheck -ErrorAction Ignore

    # Import the moduleget
    Import-Module -Name PSWindowsUpdate -Force -ErrorAction Ignore
} else {
    Write-Host "PSWindowsUpdate module is installed."
}

######### Check Winget is uptodate #########

$folderPath = "C:\temp\winget"

# Check if the folder exists
if (-not (Test-Path $folderPath)) {
    # If it doesn't exist, create the folder
    New-Item -ItemType Directory -Path $folderPath
    Write-Output "Folder created at $folderPath"
} else {
    Write-Output "Folder already exists at $folderPath"
}

#Function to install winget dependencies
function wgDependencies {
    # Set URLs for dependencies
    # Set URLs for dependencies
    $vclibsUrl = "https://aka.ms/"
    $uixamlUrl = "https://github.com/microsoft/microsoft-ui-xaml/releases/download/v2.8.6/"
    $vclibfile = "Microsoft.VCLibs.x64.14.00.Desktop.appx"
    $uixamlfile = "Microsoft.UI.Xaml.2.8.x64.appx"
    $wingetTemp = "c:\temp\winget"
    
    # Download and install the dependencies if not installed
    if (-not (Get-AppxPackage -Name "Microsoft.VCLibs.140.00")) {
        Write-Output "$vclibfile is not installed. Installing..."
        $vclibDownloadUrl = $vclibsUrl + $vclibfile
        Invoke-WebRequest -Uri $vclibDownloadUrl -OutFile "$wingetTemp\$vclibfile"
        Add-AppxPackage -Path "$wingetTemp\$vclibfile" -ErrorAction SilentlyContinue
        Write-Output "$vclibfile has been installed."
    } else {
        Write-Output "$vclibfile is already installed."
    }
    
    if (-not (Get-AppxPackage -Name "Microsoft.UI.Xaml.2.8")) {
        Write-Output "$uixamlfile is not installed. Installing..."
        $uixamlDownloadUrl = $uixamlUrl + $uixamlfile
        Invoke-WebRequest -Uri $uixamlDownloadUrl -OutFile "$wingetTemp\$uixamlfile"
        Add-AppxPackage -Path "$wingetTemp\$uixamlfile" -ErrorAction SilentlyContinue
        Write-Output "$uixamlfile has been installed."
    } else {
        Write-Output "$uixamlfile is already installed."
    }
    
    Write-Host "Dependencies have been checked and installed successfully."
    
}

function wgSource {
    param (
        [string]$SourceUrl = "https://cdn.winget.microsoft.com/cache/source.msix",
        [string]$OutputDirectory = "C:\Temp"
    )

    # Create the output directory if it doesn't exist
    if (-not (Test-Path -Path $OutputDirectory)) {
        New-Item -Path $OutputDirectory -ItemType Directory | Out-Null
    }

    # Define the path where the downloaded MSIX package will be saved
    $OutputFilePath = Join-Path -Path $OutputDirectory -ChildPath "source.msix"

    # Download the MSIX package
    Invoke-WebRequest -Uri $SourceUrl -OutFile $OutputFilePath

    # Install the downloaded MSIX package
    Add-AppxPackage -Path $OutputFilePath

    # Clean up: Remove the downloaded MSIX package after installation
    Remove-Item -Path $OutputFilePath
}

function wgInstall{
    # Download and install the latest version of winget
    Invoke-WebRequest -Uri "https://aka.ms/getwinget" -OutFile "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    Add-AppxPackage -Path "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    wgSource
    Write-Host "winget has been installed successfully."
}



# Check if winget command exists
$wingetPath = (Get-Command winget -ErrorAction SilentlyContinue).Path
if ($null -ne $wingetPath) {
    Write-Output "winget is installed at $wingetPath"
} else {
    Write-Output "winget is not installed."
    wgDependencies
    if ($systemAccounts -contains $user) {
        Write-Output "The current user is a system account - $user. Run choco winget..."
    } else {
        wgInstall
    }
}

# Function to query latest version from GitHub API
function Get-LatestVersion {
    $url = "https://api.github.com/repos/chocolatey/choco/releases/latest"
    $response = Invoke-RestMethod -Uri $url -Method Get
    $latestVersion = $response.tag_name
    return $latestVersion
}

# Check if Chocolatey is installed
if (-not (Test-Path 'C:\ProgramData\chocolatey\bin\choco.exe')) {
    # Install Chocolatey
    Set-ExecutionPolicy Bypass -Scope Process -Force
    iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
    # Add Chocolatey directory to PATH
} else {
    # Query the latest version
    $latestVersion = Get-LatestVersion

    # Get installed Chocolatey version
    $installedVersion = & 'C:\ProgramData\chocolatey\bin\choco.exe' --version

    # Compare versions
    if ($installedVersion -lt $latestVersion) {
        # Upgrade Chocolatey if it's outdated
        Write-Host "Upgrading Chocolatey to version $latestVersion"
        C:\ProgramData\chocolatey\bin\choco.exe upgrade chocolatey -y
    } else {
        Write-Host "Chocolatey is already up to date."
    }
}

#Perform Winget choco

# Check if the current user is one of the known system accounts
if ($systemAccounts -contains $user) {
    Write-Output "The current user is a system account - $user. Upgrading winget..."
    Start-Process "powershell" -ArgumentList "choco feature enable -n allowGlobalConfirmation" -Verb RunAs -Wait
    Start-Process "powershell" -ArgumentList "choco upgrade winget -y" -Verb RunAs -Wait
} else {
    Start-Process "powershell" -ArgumentList "choco feature enable -n allowGlobalConfirmation" -Verb RunAs -Wait
    wgSource
}

######### Perform Windows Update #########

#if ($RunWindowsUpdate.ToLower() -eq "yes") {
if ($RunWindowsUpdate) {
    Write-Host "*************Running Windows OS Updates*************"
    
    $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_PSUJob_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

    $windowsUpdateCommand = 'Install-WindowsUpdate -NotCategory "Drivers" -NotTitle "Firmware" -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose -Confirm:$false'
    $usoClientCommand = 'Start-Process -FilePath "C:\Windows\System32\UsoClient.exe" -ArgumentList "startinteractivescan" -NoNewWindow -Wait'

    # Using Start-Process to capture output
    Start-Process -FilePath 'powershell.exe' -ArgumentList "-NoProfile -Command $windowsUpdateCommand" -RedirectStandardOutput $logFilePath -NoNewWindow -Wait
    Invoke-Expression $usoClientCommand
} else {
    Write-Host "Windows Update not initiated. Set the -RunWindowsUpdate parameter to 'yes' to execute."
}

######### Perform Apps Update #########
function Update-Apps {
    param(
        [int]$TimeoutMinutes = 30
    )

    # Log start of the update
    Write-Host "************* Running Apps Updates (Timeout ${TimeoutMinutes}mins) *************"

    # Define the path to the WindowsApps directory
    $windowsAppsPath = "$env:ProgramFiles\WindowsApps"

    # Recursively search for winget.exe in the WindowsApps directory
    $wingetPath = Get-ChildItem -Path $windowsAppsPath -Recurse -Filter winget.exe -ErrorAction SilentlyContinue | Select-Object -First 1

    if (-not $wingetPath) {
        # Use Get-Command to find winget.exe if not found in the WindowsApps directory
        $wingetCommand = Get-Command winget.exe -ErrorAction SilentlyContinue
        if ($wingetCommand) {
            $wingetPath = $wingetCommand.Source
        }
    } else {
        $wingetPath = $wingetPath.FullName
    }

    if ($wingetPath) {
        Write-Output "winget.exe found at: $wingetPath"
        
        # Define the arguments to pass to winget.exe as an array
        $wingetArgs = @(
            "upgrade",
            "--accept-package-agreements",
            "--accept-source-agreements",
            "--all",
            "--include-unknown",
            "--force",
            "--disable-interactivity",
            "--verbose",
            "--silent"
        )
        
        # Define the log file path with timestamp
        $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_WingetJob_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
        
        # Start winget.exe as a background process
        $process = Start-Process -FilePath $wingetPath -ArgumentList $wingetArgs -PassThru -RedirectStandardOutput $logFilePath -Wait
        
        # Define the timeout duration (in seconds)
        $timeout = $TimeoutMinutes * 60
        
        # Wait for the specified timeout duration
        $process.WaitForExit($timeout * 1000)
        
        # Check if the process is still running after the timeout
        if (!$process.HasExited) {
            Write-Output "winget.exe is still running after $timeout seconds. Terminating the process."
            $process.Kill()
        } else {
            Write-Output "winget.exe completed within the timeout period."
        }
    } else {
        Write-Output "winget.exe not found on the system."
    }
}

# Call the function
if ($systemAccounts -contains $user) {
    Write-Output "The current user is a system account - Using Scheduled Task to update apps.."
} else {
    Write-Output "The current user is not a system account - Running apps update.."
    Update-Apps -TimeoutMinutes 30
    Update-Apps -TimeoutMinutes 30
}

######### Remove Silverlight #########

Write-Host "*************Checking for Silverlight*************"

# Check if Silverlight is installed
if (Get-WmiObject -Query "SELECT * FROM Win32_Product WHERE Name LIKE '%Silverlight%'") {
    Write-Host "Silverlight is installed. Removing"
    
    # Uninstall Silverlight
    $uninstallResult = (Uninstall-Package -name 'Microsoft Silverlight' -force)

} else {
    Write-Host "Silverlight is not installed."
}

######### Perform Log4j-Scan #########

Write-Host "*************Checking log4j*************"

# Check if log4j is installed
# Define variables
$jar_file = "c:\temp\log4jscan-latest.jar"
$log_file = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_log4j.log"

# Function to check if the log4j JAR file exists
function Check-JarExistence {
    param (
        [string]$jar_file
    )
    return Test-Path $jar_file
}


# Check if log4j JAR file exists
if (Check-JarExistence -jar_file $jar_file) {
    Write-Host "Using existing JAR file: $jar_file"
} else {
    # Get the latest release URL
    $latest_url = (Invoke-WebRequest -Uri "https://api.github.com/repos/logpresso/CVE-2021-44228-Scanner/releases/latest" -UseBasicParsing | ConvertFrom-Json).assets | Where-Object { $_.browser_download_url -like "*.jar" } | Select-Object -ExpandProperty browser_download_url

    # Download the latest .jar file
    Invoke-WebRequest -Uri $latest_url -OutFile $jar_file -UseBasicParsing

    # Check if download was successful
    if ($?) {
        Write-Host "Downloaded: $jar_file"
    } else {
        Write-Host "Failed to download JAR file. Exiting."
    }
}

# Run the scanner
try {
    # Execute the Java command and redirect output to the log file
    java -jar $jar_file --scan-log4j1 --no-empty-report --force-fix --all-drives > $log_file
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Scan completed. Log file: $log_file"
    } else {
        throw "Command failed with exit code $LASTEXITCODE"
    }
} catch {
    # Output failure message
    Write-Host "Failed to execute log4j scan"
}


######### Perform Ghostscript #########

Write-Host "*************Checking Ghostscript*************"


######### Windows Sanity Check Completed #########


# Stop logging
Stop-Transcript
