<#
.DESCRIPTION
  This PowerShell script is invoke windows update via PS module
.CREATED by
  Christian Mariano - NYUAD    
#>

param (
    #[bool]$RunWindowsUpdate = $false
    #[string]$RunWindowsUpdate = "no"
    [switch]$RunWindowsUpdate
)

####CODE

# Start logging

$hostname = $env:COMPUTERNAME
# Start logging with hostname included in the log filename
$LogPath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_GSD_Patch_${hostname}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
Start-Transcript -Path $LogPath -NoClobber


################ Start Script ################
Write-Host "*************Check and install Dependencies*************"
$progressPreference = 'silentlyContinue'

######### Check Nuget Provider #########

# Check if NuGet provider is installed
$nugetProvider = Get-PackageProvider -ListAvailable | Where-Object {$_.Name -eq "NuGet"}

if ($nugetProvider) {
    Write-Host "NuGet provider is installed."
} else {
    Write-Host "NuGet provider is not installed."
    # Install the NuGet provider without interaction
    Install-PackageProvider -Name NuGet -Force -Confirm:$false  -ErrorAction Ignore
}

######### Check PSWindowsUpdate #########

# Check if PSWindowsUpdate module is installed
$psWindowsUpdateInstalled = Get-Module -ListAvailable -Name PSWindowsUpdate

# If the module is not installed, notify the user
if (-not $psWindowsUpdateInstalled) {
    Write-Host "PSWindowsUpdate module is not installed."
        # Set the NuGet package provider to trust all repositories
    #Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
    Install-Module -Name PSWindowsUpdate -Repository PSGallery -Force -AllowClobber -SkipPublisherCheck -ErrorAction Ignore

    # Import the moduleget
    Import-Module -Name PSWindowsUpdate -Force -ErrorAction Ignore
} else {
    Write-Host "PSWindowsUpdate module is installed."
}

######### Check Winget is uptodate #########

$folderPath = "C:\temp\winget"

# Check if the folder exists
if (-not (Test-Path $folderPath)) {
    # If it doesn't exist, create the folder
    New-Item -ItemType Directory -Path $folderPath
    Write-Output "Folder created at $folderPath"
} else {
    Write-Output "Folder already exists at $folderPath"
}

#Function to install winget dependencies
function wgDependencies {
    # Set URLs for dependencies
    # Set URLs for dependencies
    $vclibsUrl = "https://aka.ms/"
    $uixamlUrl = "https://github.com/microsoft/microsoft-ui-xaml/releases/download/v2.8.6/"
    $vclibfile = "Microsoft.VCLibs.x64.14.00.Desktop.appx"
    $uixamlfile = "Microsoft.UI.Xaml.2.8.x64.appx"
    $wingetTemp = "c:\temp\winget"
    
    # Download and install the dependencies if not installed
    if (-not (Get-AppxPackage -Name "Microsoft.VCLibs.140.00")) {
        Write-Output "$vclibfile is not installed. Installing..."
        $vclibDownloadUrl = $vclibsUrl + $vclibfile
        Invoke-WebRequest -Uri $vclibDownloadUrl -OutFile "$wingetTemp\$vclibfile"
        Add-AppxPackage -Path "$wingetTemp\$vclibfile"
        Write-Output "$vclibfile has been installed."
    } else {
        Write-Output "$vclibfile is already installed."
    }
    
    if (-not (Get-AppxPackage -Name "Microsoft.UI.Xaml.2.8")) {
        Write-Output "$uixamlfile is not installed. Installing..."
        $uixamlDownloadUrl = $uixamlUrl + $uixamlfile
        Invoke-WebRequest -Uri $uixamlDownloadUrl -OutFile "$wingetTemp\$uixamlfile"
        Add-AppxPackage -Path "$wingetTemp\$uixamlfile"
        Write-Output "$uixamlfile has been installed."
    } else {
        Write-Output "$uixamlfile is already installed."
    }
    
    Write-Host "Dependencies have been checked and installed successfully."
    
}

function wgInstall{
    # Download and install the latest version of winget
    Invoke-WebRequest -Uri "https://aka.ms/getwinget" -OutFile "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    Add-AppxPackage -Path "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    
    Write-Host "winget has been installed successfully."
}

# Check if winget command exists
$wingetPath = (Get-Command winget -ErrorAction SilentlyContinue).Path
if ($null -ne $wingetPath) {
    Write-Output "winget is installed at $wingetPath"
} else {
    Write-Output "winget is not installed."
    wgDependencies
    wgInstall
}

# Function to query latest version from GitHub API
function Get-LatestVersion {
    $url = "https://api.github.com/repos/chocolatey/choco/releases/latest"
    $response = Invoke-RestMethod -Uri $url -Method Get
    $latestVersion = $response.tag_name
    return $latestVersion
}

# Check if Chocolatey is installed
if (-not (Test-Path 'C:\ProgramData\chocolatey\bin\choco.exe')) {
    # Install Chocolatey
    Set-ExecutionPolicy Bypass -Scope Process -Force
    iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))
    # Add Chocolatey directory to PATH
} else {
    # Query the latest version
    $latestVersion = Get-LatestVersion

    # Get installed Chocolatey version
    $installedVersion = & 'C:\ProgramData\chocolatey\bin\choco.exe' --version

    # Compare versions
    if ($installedVersion -lt $latestVersion) {
        # Upgrade Chocolatey if it's outdated
        Write-Host "Upgrading Chocolatey to version $latestVersion"
        C:\ProgramData\chocolatey\bin\choco.exe upgrade chocolatey -y
    } else {
        Write-Host "Chocolatey is already up to date."
    }
}

######### Perform Windows Update #########

#if ($RunWindowsUpdate.ToLower() -eq "yes") {
if ($RunWindowsUpdate) {
    Write-Host "*************Running Windows OS Updates*************"

    $windowsUpdateCommand = 'Install-WindowsUpdate -NotCategory "Drivers" -NotTitle "Firmware" -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose -Confirm:$false'
    $usoClientCommand = 'Start-Process -FilePath "C:\Windows\System32\UsoClient.exe" -ArgumentList "startinteractivescan" -NoNewWindow -Wait'

    Invoke-Expression $windowsUpdateCommand
    Invoke-Expression $usoClientCommand
} else {
    Write-Host "Windows Update not initiated. Set the -RunWindowsUpdate parameter to 'yes' to execute."
}

######### Perform Apps Update #########
Write-Host "*************Running Apps Updates (Timeout 30mins)*******"

# Define the path to the WindowsApps directory
$windowsAppsPath = "$env:ProgramFiles\WindowsApps"

# Recursively search for winget.exe in the WindowsApps directory
$wingetPath = Get-ChildItem -Path $windowsAppsPath -Recurse -Filter winget.exe -ErrorAction SilentlyContinue | Select-Object -First 1

if ($wingetPath) {
    Write-Output "winget.exe found at: $($wingetPath.FullName)"
    
    # Define the arguments to pass to winget.exe as an array
    $wingetArgs = @(
        "upgrade",
        "--accept-package-agreements",
        "--accept-source-agreements",
        "--all",
        "--include-unknown",
        "--force",
        "--disable-interactivity",
        "--verbose",
        "--silent"
    )
    $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_WingetJob_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
    # Start winget.exe as a background process
    $process = Start-Process -FilePath $wingetPath.FullName -ArgumentList $wingetArgs -PassThru -RedirectStandardOutput $logFilePath -Wait #-RedirectStandardError $logFilePath -Wait#-Whatif
    
    # Define the timeout duration (in seconds)
    $timeout = 1800
    
    # Wait for the specified timeout duration
    $process.WaitForExit($timeout * 1000)
    
    # Check if the process is still running after the timeout
    if (!$process.HasExited) {
        Write-Output "winget.exe is still running after $timeout seconds. Terminating the process."
        $process.Kill()
    } else {
        Write-Output "winget.exe completed within the timeout period."
    }
} else {
    Write-Output "winget.exe not found in the WindowsApps directory."
}


######### Remove Silverlight #########

Write-Host "*************Checking for Silverlight*************"

# Check if Silverlight is installed
if (Get-WmiObject -Query "SELECT * FROM Win32_Product WHERE Name LIKE '%Silverlight%'") {
    Write-Host "Silverlight is installed. Removing"
    
    # Uninstall Silverlight
    $uninstallResult = (Uninstall-Package -name 'Microsoft Silverlight' -force)

} else {
    Write-Host "Silverlight is not installed."
}

######### Perform Log4j-Scan #########

Write-Host "*************Checking log4j*************"

# Check if log4j is installed
# Define variables
$jar_file = "c:\temp\log4jscan-latest.jar"
$log_file = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_log4j.log"

# Function to check if JAR file exists
function Check-JarExistence {
    if (Test-Path $jar_file) {
        Write-Host "JAR file already exists. Skipping download."
        return $true
    } else {
        return $false
    }
}

# Check if log4j JAR file exists
if (Check-JarExistence) {
    Write-Host "Using existing JAR file: $jar_file"
} else {
    # Get the latest release URL
    $latest_url = (Invoke-WebRequest -Uri "https://api.github.com/repos/logpresso/CVE-2021-44228-Scanner/releases/latest" | ConvertFrom-Json).assets | Where-Object { $_.browser_download_url -like "*.jar" } | Select-Object -ExpandProperty browser_download_url

    # Download the latest .jar file
    Invoke-WebRequest -Uri $latest_url -OutFile $jar_file

    # Check if download was successful
    if ($?) {
        Write-Host "Downloaded: $jar_file"
    } else {
        Write-Host "Failed to download JAR file. Exiting."
    }
}

# Run the scanner
java -jar $jar_file --scan-log4j1 --no-empty-report --force-fix --all-drives > $log_file -Whatif
Write-Host "Scan completed. Log file: $log_file"

######### Perform Ghostscript #########

Write-Host "*************Checking Ghostscript*************"


######### Windows Sanity Check Completed #########


# Stop logging
Stop-Transcript
