<#
.DESCRIPTION
  This PowerShell script is invoke windows update via PS module
.CREATED by
  Christian Mariano - NYUAD    
#>

param (
    #[bool]$RunWindowsUpdate = $false
    [string]$RunWindowsUpdate = "yes"
    #[switch]$RunWindowsUpdate
)

####CODE

# Clean up old log files (older than 7 days)
$logDirectory = "C:\ProgramData\AirWatch\UnifiedAgent\Logs"
$logRetentionDays = 7
$logFiles = Get-ChildItem -Path $logDirectory -Filter "ADWX_*.log" -ErrorAction SilentlyContinue | Where-Object { $_.LastWriteTime -lt (Get-Date).AddDays(-$logRetentionDays) } 
foreach ($logFile in $logFiles) {
    try {
        Remove-Item -Path $logFile.FullName -ErrorAction Stop
        Write-Output "Deleted old log file: $($logFile.FullName)"
    } catch {
        Write-Output "Failed to delete log file: $($logFile.FullName) - $_"
    }
}

# Start logging

$hostname = $env:COMPUTERNAME
# Start logging with hostname included in the log filename
$LogPath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_GSD_Patch_${hostname}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
Start-Transcript -Path $LogPath -NoClobber

# Run the whoami command and capture the output
$user = whoami

# Define known system account names
$systemAccounts = @(
    "NT AUTHORITY\SYSTEM",      # Local System
    "NT AUTHORITY\LOCAL SERVICE",  # Local Service
    "NT AUTHORITY\NETWORK SERVICE" # Network Service
)

################ Start Script ################
Write-Host "*************Check and install Dependencies*************"
$progressPreference = 'silentlyContinue'

######### Check Nuget Provider #########

# Check if NuGet provider is installed
$nugetProvider = Get-PackageProvider -ListAvailable | Where-Object {$_.Name -eq "NuGet"}

if ($nugetProvider) {
    Write-Host "NuGet provider is installed."
} else {
    Write-Host "NuGet provider is not installed."
    # Install the NuGet provider without interaction
    Install-PackageProvider -Name NuGet -Force -Confirm:$false  -ErrorAction Ignore
}

######### Check PSWindowsUpdate #########
Write-Host "*************Checking PSU Module*************"

# Check if PSWindowsUpdate module is installed
$psWindowsUpdateInstalled = Get-Module -ListAvailable -Name PSWindowsUpdate

# If the module is not installed, notify the user
if (-not $psWindowsUpdateInstalled) {
    Write-Host "PSWindowsUpdate module is not installed."
        # Set the NuGet package provider to trust all repositories
    #Set-PSRepository -Name PSGallery -InstallationPolicy Trusted
    Install-Module -Name PSWindowsUpdate -Repository PSGallery -Force -AllowClobber -SkipPublisherCheck -ErrorAction Ignore

    # Import the moduleget
    Import-Module -Name PSWindowsUpdate -Force -ErrorAction Ignore
} else {
    Write-Host "PSWindowsUpdate module is installed."
}

######### Check Winget is uptodate #########

$folderPath = "C:\temp\winget"

# Check if the folder exists
if (-not (Test-Path $folderPath)) {
    # If it doesn't exist, create the folder
    New-Item -ItemType Directory -Path $folderPath
    Write-Output "Folder created at $folderPath"
} else {
    Write-Output "Folder already exists at $folderPath"
}

#Function to install winget dependencies
function wgDependencies {
    # Set URLs for dependencies
    # Set URLs for dependencies
    $vclibsUrl = "https://aka.ms/"
    $uixamlUrl = "https://github.com/microsoft/microsoft-ui-xaml/releases/download/v2.8.6/"
    $vclibfile = "Microsoft.VCLibs.x64.14.00.Desktop.appx"
    $uixamlfile = "Microsoft.UI.Xaml.2.8.x64.appx"
    $wingetTemp = "c:\temp\winget"
    
    # Download and install the dependencies if not installed
    if (-not (Get-AppxPackage -Name "Microsoft.VCLibs.140.00")) {
        Write-Output "$vclibfile is not installed. Installing..."
        $vclibDownloadUrl = $vclibsUrl + $vclibfile
        Invoke-WebRequest -Uri $vclibDownloadUrl -OutFile "$wingetTemp\$vclibfile"
        Add-AppxPackage -Path "$wingetTemp\$vclibfile" -ErrorAction SilentlyContinue
        Write-Output "$vclibfile has been installed."
    } else {
        Write-Output "$vclibfile is already installed."
    }
    
    if (-not (Get-AppxPackage -Name "Microsoft.UI.Xaml.2.8")) {
        Write-Output "$uixamlfile is not installed. Installing..."
        $uixamlDownloadUrl = $uixamlUrl + $uixamlfile
        Invoke-WebRequest -Uri $uixamlDownloadUrl -OutFile "$wingetTemp\$uixamlfile"
        Add-AppxPackage -Path "$wingetTemp\$uixamlfile" -ErrorAction SilentlyContinue
        Write-Output "$uixamlfile has been installed."
    } else {
        Write-Output "$uixamlfile is already installed."
    }
    
    Write-Host "Dependencies have been checked and installed successfully."
    
}

function wgSource {
    param (
        [string]$SourceUrl = "https://cdn.winget.microsoft.com/cache/source.msix",
        [string]$OutputDirectory = "C:\Temp"
    )

    # Create the output directory if it doesn't exist
    if (-not (Test-Path -Path $OutputDirectory)) {
        New-Item -Path $OutputDirectory -ItemType Directory | Out-Null
    }

    # Define the path where the downloaded MSIX package will be saved
    $OutputFilePath = Join-Path -Path $OutputDirectory -ChildPath "source.msix"

    # Download the MSIX package
    Invoke-WebRequest -Uri $SourceUrl -OutFile $OutputFilePath

    # Install the downloaded MSIX package
    Add-AppxPackage -Path $OutputFilePath

    # Clean up: Remove the downloaded MSIX package after installation
    Remove-Item -Path $OutputFilePath
}

function wgInstall{
    # Download and install the latest version of winget
    Invoke-WebRequest -Uri "https://aka.ms/getwinget" -OutFile "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    Add-AppxPackage -Path "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle"
    wgSource
    Write-Host "winget has been installed successfully."
}



# Check if winget command exists
$wingetPath = (Get-Command winget -ErrorAction SilentlyContinue).Path
if ($null -ne $wingetPath) {
    Write-Output "winget is installed at $wingetPath"
} else {
    Write-Output "winget is not installed."
    wgDependencies
    if ($systemAccounts -contains $user) {
        Write-Output "The current user is a system account - $user. Run choco winget..."
    } else {
        wgInstall
    }
}

# Remove Choco
if ((Test-Path 'C:\ProgramData\chocolatey\bin\choco.exe')) {
    Remove-Item -Recurse -Force "$env:ChocolateyInstall" #-WhatIf
    [System.Text.RegularExpressions.Regex]::Replace([Microsoft.Win32.Registry]::CurrentUser.OpenSubKey('Environment').GetValue('PATH', '', [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames).ToString(), [System.Text.RegularExpressions.Regex]::Escape("$env:ChocolateyInstall\bin") + '(?>;)?', '', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) | %{[System.Environment]::SetEnvironmentVariable('PATH', $_, 'User')}
    [System.Text.RegularExpressions.Regex]::Replace([Microsoft.Win32.Registry]::LocalMachine.OpenSubKey('SYSTEM\CurrentControlSet\Control\Session Manager\Environment\').GetValue('PATH', '', [Microsoft.Win32.RegistryValueOptions]::DoNotExpandEnvironmentNames).ToString(),  [System.Text.RegularExpressions.Regex]::Escape("$env:ChocolateyInstall\bin") + '(?>;)?', '', [System.Text.RegularExpressions.RegexOptions]::IgnoreCase) | %{[System.Environment]::SetEnvironmentVariable('PATH', $_, 'Machine')}

    if ($env:ChocolateyBinRoot -ne '' -and $env:ChocolateyBinRoot -ne $null) { Remove-Item -Recurse -Force "$env:ChocolateyBinRoot" } #-WhatIf }
    if ($env:ChocolateyToolsRoot -ne '' -and $env:ChocolateyToolsRoot -ne $null) { Remove-Item -Recurse -Force "$env:ChocolateyToolsRoot" } #-WhatIf }
    [System.Environment]::SetEnvironmentVariable("ChocolateyBinRoot", $null, 'User')
    [System.Environment]::SetEnvironmentVariable("ChocolateyToolsLocation", $null, 'User')
    Write-Output "Choco removed"
}

######### Perform Windows Update #########
Write-Host "*************Running Windows OS Updates*************"

#if ($RunWindowsUpdate.ToLower() -eq "yes") {
$usoClientCommand = 'Start-Process -FilePath "C:\Windows\System32\UsoClient.exe" -ArgumentList "startinteractivescan" -NoNewWindow -Wait'
if ($RunWindowsUpdate) {

    if (($(whoami) -eq 'NT AUTHORITY\SYSTEM') -and (Test-Path 'C:\temp\firstime.txt')) {
        Write-Host "Detected as OSD process is runinng"
        $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_PSUJobFS_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
        $windowsUpdateCommand = 'Install-WindowsUpdate -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose -Confirm:$false'
        # Using Start-Process to capture output
        Start-Process -FilePath 'powershell.exe' -ArgumentList "-NoProfile -Command $windowsUpdateCommand" -RedirectStandardOutput $logFilePath -NoNewWindow -Wait
        Invoke-Expression $usoClientCommand
        Remove-Item 'C:\temp\firstime.txt' -Force
        Write-Host "File removed"
    } else {
        Write-Host "Detected as GSD process is runinng"
        $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_PSUJob_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
        $windowsUpdateCommand = 'Install-WindowsUpdate -NotCategory "Drivers" -NotTitle "Firmware" -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose -Confirm:$false'
        # Using Start-Process to capture output
        Start-Process -FilePath 'powershell.exe' -ArgumentList "-NoProfile -Command $windowsUpdateCommand" -RedirectStandardOutput $logFilePath -NoNewWindow -Wait
        Invoke-Expression $usoClientCommand
    }
        
} else {
    Write-Host "Windows Update not initiated. Set the -RunWindowsUpdate parameter to 'yes' to execute."
}

######### Perform Apps Update #########
# Define the URLs and paths
$psexecUrl = "https://github.com/xtian08/ADrepo/raw/main/PsExec.exe"
$psexecPath = "C:\temp\psexec.exe"

# Check if PsExec.exe is already present
if (-Not (Test-Path $psexecPath)) {
    # Create the directory if it doesn't exist
    if (-Not (Test-Path "C:\temp")) {
        New-Item -Path "C:\temp" -ItemType Directory
    }

    # Download PsExec.exe
    Invoke-WebRequest -Uri $psexecUrl -OutFile $psexecPath
}

function Update-Apps {
    param(
        [int]$TimeoutMinutes = 30
    )

    # Log start of the update
    Write-Host "************* Running Apps Updates (Timeout ${TimeoutMinutes}mins) *************"

    # Define the path to the WindowsApps directory
    $windowsAppsPath = "$env:ProgramFiles\WindowsApps"
    $wingetPath = Get-ChildItem -Path $windowsAppsPath -Filter winget.exe -Recurse -ErrorAction SilentlyContinue -Force | Select-Object -First 1 -ExpandProperty FullName
    
    if ($wingetPath) {
        Write-Output "winget.exe found at: $wingetPath"
        
        # Define the arguments to pass to winget.exe as an array
        $wingetArgs = @(
            "upgrade",
            "--accept-package-agreements",
            "--accept-source-agreements",
            "--all",
            "--include-unknown",
            "--force",
            "--disable-interactivity",
            "--verbose",
            "--silent"
        )
        
        # Define the log file path with timestamp
        $logFilePath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_WingetJob_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"

        # Define the command to run winget
        $wingetCommand = "`"$wingetPath`" $wingetArgs"
        echo $wingetCommand
        
        # Start winget.exe as a background process
        $process = Start-Process -FilePath $psexecPath -ArgumentList "/accepteula -i 1 -s cmd /c $wingetCommand > $logFilePath 2>&1" -PassThru -Wait -NoNewWindow 

        # Check for errors in the process log file
        if (Test-Path $logFilePath) {
            $logContent = Get-Content -Path $logFilePath
            if ($logContent) {
                Write-Output "Log file content:"
                Write-Output $logContent
            } else {
                Write-Output "Log file is empty."
            }
        } else {
            Write-Output "Log file not found."
        }

        # Define the timeout duration (in seconds)
        $timeout = $TimeoutMinutes * 60
        
        # Wait for the specified timeout duration
        $process.WaitForExit($timeout * 1000)
        
        # Check if the process is still running after the timeout
        if (!$process.HasExited) {
            Write-Output "winget.exe is still running after $timeout seconds. Terminating the process."
            $process.Kill()
        } else {
            Write-Output "winget.exe completed within the timeout period."
        }

    } else {
        Write-Output "winget.exe not found on the system."
    }
}

#Perform twice
Update-Apps -TimeoutMinutes 30
Update-Apps -TimeoutMinutes 30


######### Remove Silverlight #########

Write-Host "*************Checking for Silverlight*************"

# Check if Silverlight is installed
if (Get-WmiObject -Query "SELECT * FROM Win32_Product WHERE Name LIKE '%Silverlight%'") {
    Write-Host "Silverlight is installed. Removing"
    
    # Uninstall Silverlight
    $uninstallResult = (Uninstall-Package -name 'Microsoft Silverlight' -force)

} else {
    Write-Host "Silverlight is not installed."
}

######### Perform Log4j-Scan #########

Write-Host "*************Checking log4j*************"

# Check if log4j is installed
# Define variables
$jar_file = "c:\temp\log4jscan-latest.jar"
$log_file = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_log4j.log"

# Function to check if the log4j JAR file exists
function Check-JarExistence {
    param (
        [string]$jar_file
    )
    return Test-Path $jar_file
}


# Check if log4j JAR file exists
if (Check-JarExistence -jar_file $jar_file) {
    Write-Host "Using existing JAR file: $jar_file"
} else {
    # Get the latest release URL
    $latest_url = (Invoke-WebRequest -Uri "https://api.github.com/repos/logpresso/CVE-2021-44228-Scanner/releases/latest" -UseBasicParsing | ConvertFrom-Json).assets | Where-Object { $_.browser_download_url -like "*.jar" } | Select-Object -ExpandProperty browser_download_url

    # Download the latest .jar file
    Invoke-WebRequest -Uri $latest_url -OutFile $jar_file -UseBasicParsing

    # Check if download was successful
    if ($?) {
        Write-Host "Downloaded: $jar_file"
    } else {
        Write-Host "Failed to download JAR file. Exiting."
    }
}

# Run the scanner
try {
    # Execute the Java command and redirect output to the log file
    java -jar $jar_file --scan-log4j1 --no-empty-report --force-fix --all-drives > $log_file
    if ($LASTEXITCODE -eq 0) {
        Write-Host "Scan completed. Log file: $log_file"
    } else {
        throw "Command failed with exit code $LASTEXITCODE"
    }
} catch {
    # Output failure message
    Write-Host "Failed to execute log4j scan"
}


######### Perform Ghostscript #########

Write-Host "*************Checking Ghostscript*************"

function 7zipCheck {

# Get the current PATH environment variable
$currentPath = [System.Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)

# Check if 7-Zip path is already in the PATH
if ($currentPath -like "*$sevenZipPath*") {
    Write-Output "7-Zip path is already in the PATH environment variable."
} else {
    # Add the 7-Zip path to the PATH environment variable
    $newPath = "$currentPath;$sevenZipPath"
    [System.Environment]::SetEnvironmentVariable("Path", $newPath, [System.EnvironmentVariableTarget]::Machine)
    Write-Output "7-Zip path added to the PATH environment variable."
}

# Display the updated PATH environment variable
$updatedPath = [System.Environment]::GetEnvironmentVariable("Path", [System.EnvironmentVariableTarget]::Machine)
Write-Output "Updated PATH: $updatedPath"
}

function DownloadGS {


# Define the GitHub repository and release tag
$repository = "ArtifexSoftware/ghostpdl-downloads"
$tag = "latest"

# Get the release information from GitHub API
$releaseInfo = Invoke-RestMethod -Uri "https://api.github.com/repos/$repository/releases/$tag"

# Loop through each asset in the release
foreach ($asset in $releaseInfo.assets) {
    $downloadUrl = $asset.browser_download_url
    $fileName = $asset.name

    # Check if the file matches the desired prefix and suffix
    if ($fileName -like "gs*.exe") {
        # Define the output file path
        $outputFile = "C:\temp\$fileName"

        # Check if the file doesn't already exist in the download folder
        if (-not (Test-Path $outputFile)) {
            # Download the asset
            Invoke-WebRequest -Uri $downloadUrl -OutFile $outputFile
            Write-Host "Downloaded $fileName to $outputFile"
        } else {
            Write-Host "$fileName already exists in the download folder."
        }
    }
}
}

# Function to find and run uninstgs.exe
function Remove-GsFoldersAndRegistry {
    $paths = @(
        "C:\Program Files\gs",
        "C:\Program Files (x86)\gs"
    )

    $registryKeys = @(
        "HKLM:\SOFTWARE\Artifex\GPL Ghostscript",
        "HKLM:\SOFTWARE\GPL Ghostscript"
    )

    # Remove folders
    foreach ($path in $paths) {
        if (Test-Path $path) {
            try {
                Remove-Item -Path $path -Recurse -Force -ErrorAction Stop
                Write-Output "Successfully deleted folder: $path"
            } catch {
                Write-Error "Failed to delete folder: $path. Error: $_"
            }
        } else {
            Write-Output "Folder does not exist: $path"
        }
    }

    # Remove registry keys
    foreach ($key in $registryKeys) {
        if (Test-Path $key) {
            try {
                Remove-Item -Path $key -Recurse -Force -ErrorAction Stop
                Write-Output "Successfully deleted registry key: $key"
            } catch {
                Write-Error "Failed to delete registry key: $key. Error: $_"
            }
        } else {
            Write-Output "Registry key does not exist: $key"
        }
    }
}

function Uninstall-Ghostscript {
    $paths = @(
        "C:\Program Files\gs",
        "C:\Program Files (x86)\gs"
    )

    $uninstallers = @()

    # Search for uninstgs.exe in the specified directories and their subdirectories
    foreach ($path in $paths) {
        Write-Output "Searching for uninstgs.exe in $path..."
        $results = Get-ChildItem -Path $path -Recurse -Filter uninstgs.exe -ErrorAction SilentlyContinue
        $uninstallers += $results
    }

    if ($uninstallers.Count -gt 0) {
        Write-Output "Found the following uninstallers:"
        $uninstallers | ForEach-Object { Write-Output " - $($_.FullName)" }

        # Run each found uninstaller
        foreach ($uninstaller in $uninstallers) {
            Write-Output "Attempting to run uninstaller: $($uninstaller.FullName)"
            try {
                Start-Process -FilePath $uninstaller.FullName -ArgumentList "/S" -Wait -ErrorAction Stop
                Write-Output "Successfully ran uninstaller: $($uninstaller.FullName)"
            } catch {
                Write-Output "Failed to run uninstaller: $($uninstaller.FullName). Error: $_"
            }
        }
    } else {
        Write-Output "No uninstgs.exe found in the specified directories."

    }
}

# Function to install the appropriate Ghostscript version using Chocolatey
function Install-Ghostscript {

    Set-Location C:\temp

    & "C:\Program Files\7-Zip\7z.exe" x -y -xr!$PLUGINSDIR -xr!"*.nsis" -xr!"vcredist*" -o"C:\Program Files\gs\gs10.03.1" "gs10031w64.exe"

    & "C:\Program Files\7-Zip\7z.exe" x -y -ir!"Identity-UTF16-H" -o"C:\Program Files\gs\gs10.03.1" "gs10031w64.exe"

    & "C:\Program Files\7-Zip\7z.exe" x -y -ir!bin -o"C:\Program Files\gs\gs10.03.1" "gs10031w32.exe"

    reg.exe ADD "HKLM\SOFTWARE\Artifex\GPL Ghostscript\10.03.1" /ve /d "C:\Program Files\gs\gs10.03.1" /f 
    reg.exe ADD "HKLM\SOFTWARE\GPL Ghostscript\10.03.1" /v "GS_DLL" /t REG_SZ /d "C:\Program Files\gs\gs10.03.1\bin\gsdll64.dll;C:\Program Files\gs\gs10.03.1\bin\gsdll32.dll" /f 
    reg.exe ADD "HKLM\SOFTWARE\GPL Ghostscript\10.03.1" /v "GS_LIB" /t REG_SZ /d "C:\Program Files\gs\gs10.03.1\bin;C:\Program Files\gs\gs10.03.1\lib;C:\Program Files\gs\gs10.03.1\fonts" /f

    # Check if the path exists in the PATH environment variable
    $gsPath = "C:\Program Files\gs\gs10.03.1\bin"
    if ($env:PATH -split ";" -contains $gsPath) {
        Write-Output "GS bin already in PATH."
    } else {
        Write-Output "Adding GS bin to PATH."
        $newPath = $env:PATH + ";" + $gsPath
        [System.Environment]::SetEnvironmentVariable("PATH", $newPath, [System.EnvironmentVariableTarget]::Machine)
    }

}

function Test-GhostscriptExecutable {
    # Define the paths where Ghostscript executables might be located
    $gsPaths = @(
        "C:\Program Files\gs\gs*\bin\gswin64c.exe",  # 64-bit version
        "C:\Program Files (x86)\gs\gs*\bin\gswin64c.exe",  # 64-bit version in x86 folder
        "C:\Program Files\gs\gs*\bin\gswin32c.exe",  # 32-bit version
        "C:\Program Files (x86)\gs\gs*\bin\gswin32c.exe"  # 32-bit version in x86 folder
    )

    # Iterate over each path and check if the executable exists and is executable
    foreach ($path in $gsPaths) {
        $gsExecutable = Get-ChildItem $path -ErrorAction SilentlyContinue
        if ($gsExecutable -ne $null -and $gsExecutable -is [System.IO.FileInfo]) {
            Write-Output "$($gsExecutable.FullName) is executable."
            # If you want to execute the executable, you can uncomment the line below
            # Start-Process $gsExecutable.FullName
            Write-Output "Ghostscript executable found."
            return $true
        }
    }

    Write-Output "No Ghostscript executable found."
    return $false
}

$paths = @(
    "C:\Program Files\gs",
    "C:\Program Files (x86)\gs"
)

$gsFolderExists = $false

foreach ($path in $paths) {
    if (Test-Path $path) {
        $gsFolderExists = $true
        break
    }
}

if (-not $gsFolderExists) {
    Write-Output "Ghostscript folder not found. Skipped install process."
} else {
    # Run the installation process
    Write-Output "Ghostscript folder found. Starting install process."
    7zipCheck
    DownloadGS
    Uninstall-Ghostscript
    Remove-GsFoldersAndRegistry
    Install-Ghostscript
    Test-GhostscriptExecutable
}

######### Perform Java Check #########

Write-Host "*************Checking Java*************"


# Define the path to check
$javaPath = "C:\Program Files\Java"

# Initialize the boolean parameters
$containsJDK = $false
$containsJRE = $false
$simulateUninstall = $false # Change this to $false to perform actual uninstallation

# Function to uninstall JDK or JRE
function Uninstall-Software {
    param (
        [string]$softwarePattern,
        [bool]$simulate
    )

    # Get the uninstall command from the registry
    $uninstallKeys = Get-ChildItem -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall", "HKLM:\Software\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall" |
                     Get-ItemProperty |
                     Where-Object { $_.DisplayName -match $softwarePattern }

    foreach ($key in $uninstallKeys) {
        if ($key.UninstallString) {
            # Replace MsiExec.exe /I with MsiExec.exe /X if found
            $uninstallCommand = $key.UninstallString -replace "MsiExec.exe /I", "MsiExec.exe /X"
            
            if ($simulate) {
                Write-Output "Simulating uninstallation of $($key.DisplayName) using command: $uninstallCommand"
            } else {
                Write-Output "Uninstalling $($key.DisplayName) using command: $uninstallCommand"
                & cmd.exe /c $uninstallCommand /quiet /norestart
            }
        }
    }
}

# Check if the path exists
if (Test-Path $javaPath) {
    # Check for subfolders containing "jdk" in their name
    $containsJDK = Get-ChildItem -Path $javaPath -Directory | Where-Object { $_.Name -like "*jdk*" } | ForEach-Object { $true }
    
    # Check for subfolders containing "jre" in their name
    $containsJRE = Get-ChildItem -Path $javaPath -Directory | Where-Object { $_.Name -like "*jre*" } | ForEach-Object { $true }
}

# Output the results and uninstall if found
if ($containsJDK) {
    Write-Output "JDK folder found. Parameter containsJDK set to True."
    Uninstall-Software -softwarePattern "SE Development Kit" -simulate $simulateUninstall
} else {
    Write-Output "No JDK folder found. Parameter containsJDK remains False."
}

if ($containsJRE) {
    Write-Output "JRE folder found. Parameter containsJRE set to True."
    Uninstall-Software -softwarePattern "Java \d+ update" -simulate $simulateUninstall
} else {
    Write-Output "No JRE folder found. Parameter containsJRE remains False."
}

# Clean Folder
Remove-Item -Path $javaPath -Force -Recurse
if ($containsJDK) {
    Start-Process -FilePath $wingetPath -ArgumentList "install Oracle.JDK.22"
}

if ($containsJRE) {
    Start-Process -FilePath $wingetPath -ArgumentList "install Oracle.JavaRuntimeEnvironment"
} 

######### Perform Firefox Check #########

Write-Host "*************Checking Firefox*************"


 # Define the main function to search and simulate/delete Mozilla Firefox entries
function Search_Clean_FF_reg {
    param (
        [bool]$simulateDelete = $true
    )
    
    # Define the paths to search within HKEY_USERS, HKEY_LOCAL_MACHINE, WOW6432Node, and WowAA32Node
    $hkeyUsersPath = "Registry::HKEY_USERS"
    $hkeyLocalMachineBasePath = "Registry::HKEY_LOCAL_MACHINE\Software"
    $mozillaFirefoxPath = "Mozilla\Firefox"
    $wow6432NodePath = "WOW6432Node"
    $wowAA32NodePath = "WowAA32Node"

    # Get all user SIDs
    $userSIDs = Get-ChildItem -Path $hkeyUsersPath

    # Define a function to search for old Mozilla Firefox registry entries in HKEY_USERS and its WOW6432Node and WowAA32Node
    function Search-MozillaEntriesInHKU {
        param (
            [string]$userSID,
            [string]$firefoxPath,
            [bool]$simulateDelete
        )
        
        $firefoxKeyPaths = @(
            "$userSID\Software\$firefoxPath",
            "$userSID\Software\$wow6432NodePath\$firefoxPath",
            "$userSID\Software\$wowAA32NodePath\$firefoxPath"
        )
        
        foreach ($firefoxKeyPath in $firefoxKeyPaths) {
            try {
                # Check if the Firefox key exists in HKEY_USERS
                if (Test-Path -Path "$hkeyUsersPath\$firefoxKeyPath") {
                    Write-Output "Mozilla Firefox entries found for user SID: $userSID at $firefoxKeyPath"
                    
                    # Get all subkeys and values under the Firefox key
                    $firefoxKey = Get-ChildItem -Path "$hkeyUsersPath\$firefoxKeyPath" -Recurse
                    foreach ($item in $firefoxKey) {
                        if ($simulateDelete) {
                            Write-Output "Simulation: Deleting $($item.PSPath)"
                        } else {
                            Remove-Item -Path $item.PSPath -Recurse -Force
                            Write-Output "Deleted $($item.PSPath)"
                        }
                    }
                }
            } catch {
                Write-Error "Error accessing registry path for user SID: $userSID at $firefoxKeyPath. $_"
            }
        }
    }

    # Define a function to search for old Mozilla Firefox registry entries in HKEY_LOCAL_MACHINE and its WOW6432Node and WowAA32Node
    function Search-MozillaEntriesInHKLM {
        param (
            [string]$basePath,
            [string]$firefoxPath,
            [string]$description,
            [bool]$simulateDelete
        )
        
        $fullPath = "$basePath\$firefoxPath"
        
        try {
            # Check if the Firefox key exists in the specified path
            if (Test-Path -Path $fullPath) {
                Write-Output "Mozilla Firefox entries found in $description"
                
                # Get all subkeys and values under the Firefox key
                $firefoxKey = Get-ChildItem -Path $fullPath -Recurse
                foreach ($item in $firefoxKey) {
                    if ($simulateDelete) {
                        Write-Output "Simulation: Deleting $($item.PSPath)"
                    } else {
                        Remove-Item -Path $item.PSPath -Recurse -Force
                        Write-Output "Deleted $($item.PSPath)"
                    }
                }
            }
        } catch {
            Write-Error "Error accessing registry path in $description. $_"
        }
    }

    # Simulate deletion of found Mozilla Firefox entries in HKEY_USERS and its WOW6432Node and WowAA32Node
    foreach ($userSID in $userSIDs) {
        Search-MozillaEntriesInHKU -userSID $userSID.PSChildName -firefoxPath $mozillaFirefoxPath -simulateDelete $simulateDelete
    }

    # Simulate deletion of found Mozilla Firefox entries in HKEY_LOCAL_MACHINE and its WOW6432Node and WowAA32Node
    $localMachinePaths = @(
        "$hkeyLocalMachineBasePath",
        "$hkeyLocalMachineBasePath\$wow6432NodePath",
        "$hkeyLocalMachineBasePath\$wowAA32NodePath"
    )

    foreach ($path in $localMachinePaths) {
        $description = $path.Replace("Registry::", "")
        Search-MozillaEntriesInHKLM -basePath $path -firefoxPath $mozillaFirefoxPath -description $description -simulateDelete $simulateDelete
    }
}

function check-FF {

    #Get Installed Firefox Version
    $firefoxPath86 = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue
    $firefoxPath64 = Get-ChildItem -Path "${env:ProgramFiles}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue
    $firefoxPathARM = Get-ChildItem -Path "${env:ProgramFiles(ARM)}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue
    
    $firefoxPath = $firefoxPath86, $firefoxPath64, $firefoxPathARM | Where-Object { $_ -ne $null } | Select-Object -First 1
    
    if ($firefoxPath) {
        Write-Host ""
        $firefoxVersion = (Get-Command $firefoxPath.FullName).FileVersionInfo.FileVersion
        $firefoxType = if ($firefoxPath -eq $firefoxPath86) { "x86" } elseif ($firefoxPath -eq $firefoxPath64) { "x64" } else { "ARM" }
        Write-Host "Firefox installed is based on $firefoxType"
        Write-Host "Installed Firefox Version: $firefoxVersion"
    }
    else {
        Write-Host ""
        Write-Host "Firefox not found. Exiting"
        break
    
    } 
} 

function install-FF {
    $progressPreference = 'silentlyContinue'
    #Get Firefox latest stable version
    [Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
    $j = Invoke-RestMethod -Uri 'https://product-details.mozilla.org/1.0/firefox_versions.json'
    $stableversion = $j.LATEST_FIREFOX_VERSION
    Write-Host "Latest stable firefox: $stableversion"
    
    # Define the download URLs for x64 and ARM versions
    $firefoxURLx64 = "https://download.mozilla.org/?product=firefox-latest&os=win64&lang=en-US"
    $firefoxURLarm = "https://download.mozilla.org/?product=firefox-latest&os=win64-aarch64&lang=en-US"
    
    # Define the installation directory
    $installDir = "C:\Program Files\Mozilla Firefox"
    
    # Create a WebClient object
    $webClient = New-Object System.Net.WebClient
    
    # Download and install Firefox based on the architecture
    if ($architecture -like "*ARM*") {
        Write-Host "Installing ARM Firefox..."
        $webClient.DownloadFile($firefoxURLarm, "$env:TEMP\firefox-installer.exe")
        Start-Process -Wait -FilePath "$env:TEMP\firefox-installer.exe" -ArgumentList "/S"
    } else {
        Write-Host "Installing 64-bit Firefox..."
        $webClient.DownloadFile($firefoxURLx64, "$env:TEMP\firefox-installer.exe")
        Start-Process -Wait -FilePath "$env:TEMP\firefox-installer.exe" -ArgumentList "/S"
    }
    
    # Clean up the installer
    Remove-Item -Path "$env:TEMP\firefox-installer.exe" -Force
    
    Write-Host "Firefox installation completed."
    
}
    
function check-FF {

#Get Installed Firefox Version
$firefoxPath86 = Get-ChildItem -Path "${env:ProgramFiles(x86)}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue
$firefoxPath64 = Get-ChildItem -Path "${env:ProgramFiles}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue
$firefoxPathARM = Get-ChildItem -Path "${env:ProgramFiles(ARM)}\Mozilla Firefox\firefox.exe" -ErrorAction SilentlyContinue

$firefoxPath = $firefoxPath86, $firefoxPath64, $firefoxPathARM | Where-Object { $_ -ne $null } | Select-Object -First 1

if ($firefoxPath) {
    Write-Host ""
    $firefoxVersion = (Get-Command $firefoxPath.FullName).FileVersionInfo.FileVersion
    $firefoxType = if ($firefoxPath -eq $firefoxPath86) { "x86" } elseif ($firefoxPath -eq $firefoxPath64) { "x64" } else { "ARM" }
    Write-Host "Firefox installed is based on $firefoxType"
    Write-Host "Installed Firefox Version: $firefoxVersion"
    install-FF
}
else {
    Write-Host ""
    Write-Host "Firefox not found. Exiting"
} 
}
       
# Call the function with the desired simulation flag
Search_Clean_FF_reg -simulateDelete $false
check-FF

######### Perform Adobe KCCC RUM updater #########

# Define the URLs and paths
$psexecUrl = "https://github.com/NYUAD-IT/nyrepo/raw/main/PsExec.exe"
$psexecPath = "C:\temp\psexec.exe"
$wglogFile = "C:\temp\winget_log.txt"
$creativeCloudPath = "C:\Program Files\Adobe\Adobe Creative Cloud\ACC\Creative Cloud.exe"
$adobeRUMPath = "C:\Program Files (x86)\Common Files\Adobe\OOBE_Enterprise\RemoteUpdateManager\RemoteUpdateManager.exe"
$installerPath = "$env:TEMP\ACCC_Set-Up.exe"

# Function to run Adobe RUM silently
function Run-AdobeRUM {
    if (Test-Path $adobeRUMPath) {
        & $adobeRUMPath
    } else {
        Write-Output "Adobe Remote Update Manager is not installed."
    }
}

# Check if PsExec.exe is already present
if (-Not (Test-Path $psexecPath)) {
    # Create the directory if it doesn't exist
    if (-Not (Test-Path "C:\temp")) {
        New-Item -Path "C:\temp" -ItemType Directory
    }

    # Download PsExec.exe
    Invoke-WebRequest -Uri $psexecUrl -OutFile $psexecPath
}

# Find winget.exe
$wingetPath = Get-ChildItem -Path "C:\Program Files\" -Filter winget.exe -Recurse -ErrorAction SilentlyContinue -Force | Select-Object -First 1 -ExpandProperty FullName

if (-Not $wingetPath) {
    Write-Error "winget.exe not found."
    exit
}

# Check if Creative Cloud is installed
if (Test-Path $creativeCloudPath) {
    Write-Output "Adobe Creative Cloud is already installed."
    Run-AdobeRUM
} else {
    Write-Output "Adobe Creative Cloud is not installed. Installing using winget..."
    
    # Define the command to run winget
    $wingetCommand = "`"$wingetPath`" install --id Adobe.CreativeCloud --silent --accept-package-agreements --accept-source-agreements -e"

    # Run winget command as SYSTEM using PsExec and log the output
    Start-Process -FilePath $psexecPath -ArgumentList "/accepteula -i 1 -s cmd /c $wingetCommand > $wglogFile" -Wait -NoNewWindow

    # Output the process log file path
    Write-Output "The process output has been logged to $wglogFile"

    # Check for errors in the process log file
    if (Test-Path $wglogFile) {
        $wglogContent = Get-Content -Path $wglogFile
        if ($wglogContent) {
            Write-Output "Log file content:"
            Write-Output $wglogContent
        } else {
            Write-Output "Log file is empty."
        }
    } else {
        Write-Output "Log file not found."
    }

    # Run Adobe RUM after installation
    Run-AdobeRUM
}

######### Windows Sanity Check Completed #########

# Stop logging
Stop-Transcript

#################################################
