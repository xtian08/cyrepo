<#
.DESCRIPTION
  This PowerShell script invokes Windows Update via PS module.
.CREATED by
  Christian Mariano - NYUAD    
#>

####CODE

# Get the hostname
$hostname = $env:COMPUTERNAME

# Start logging with hostname included in the log filename
$LogPath = "C:\ProgramData\AirWatch\UnifiedAgent\Logs\ADWX_GSD_Patch_${hostname}_$(Get-Date -Format 'yyyyMMdd_HHmmss').log"
Start-Transcript -Path $LogPath -NoClobber

# Initialize error flag
$errorOccurred = $false

# Function to log errors and set the error flag
function Handle-Error {
    param (
        [string]$message
    )
    Write-Host "Error: $message"
    $global:errorOccurred = $true
}

try {
    ################ Start Script ################
    Write-Host "*************Check and install Dependencies*************"

    ######### Check Nuget Provider #########

    # Check if NuGet provider is installed
    try {
        $nugetProvider = Get-PackageProvider -ListAvailable | Where-Object {$_.Name -eq "NuGet"}
        if ($nugetProvider) {
            Write-Host "NuGet provider is installed."
        } else {
            Write-Host "NuGet provider is not installed."
            # Install the NuGet provider without interaction
            Install-PackageProvider -Name NuGet -Force -Confirm:$false -ErrorAction Stop
        }
    } catch {
        Handle-Error "Failed to check or install NuGet provider: $_"
    }

    ######### Check PSWindowsUpdate #########

    # Check if PSWindowsUpdate module is installed
    try {
        $psWindowsUpdateInstalled = Get-Module -ListAvailable -Name PSWindowsUpdate

        # If the module is not installed, notify the user
        if (-not $psWindowsUpdateInstalled) {
            Write-Host "PSWindowsUpdate module is not installed."
            # Install the PSWindowsUpdate module
            Install-Module -Name PSWindowsUpdate -Repository PSGallery -Force -AllowClobber -SkipPublisherCheck -ErrorAction Stop

            # Import the module
            Import-Module -Name PSWindowsUpdate -Force -ErrorAction Stop
        } else {
            Write-Host "PSWindowsUpdate module is installed."
        }
    } catch {
        Handle-Error "Failed to check or install PSWindowsUpdate module: $_"
    }

    ######### Check Winget is up to date #########

    try {
        $folderPath = "C:\temp\winget"

        # Check if the folder exists
        if (-not (Test-Path $folderPath)) {
            # If it doesn't exist, create the folder
            New-Item -ItemType Directory -Path $folderPath -ErrorAction Stop
            Write-Output "Folder created at $folderPath"
        } else {
            Write-Output "Folder already exists at $folderPath"
        }

        # Function to install winget dependencies
        function wgDependencies {
            # Set URLs for dependencies
            $vclibsUrl = "https://aka.ms/"
            $uixamlUrl = "https://github.com/microsoft/microsoft-ui-xaml/releases/download/v2.8.6/"
            $vclibfile = "Microsoft.VCLibs.x64.14.00.Desktop.appx"
            $uixamlfile = "Microsoft.UI.Xaml.2.8.x64.appx"
            $wingetTemp = "c:\temp\winget"
            
            # Download and install the dependencies if not installed
            if (-not (Get-AppxPackage -Name "Microsoft.VCLibs.140.00")) {
                Write-Output "$vclibfile is not installed. Installing..."
                $vclibDownloadUrl = $vclibsUrl + $vclibfile
                Invoke-WebRequest -Uri $vclibDownloadUrl -OutFile "$wingetTemp\$vclibfile" -ErrorAction Stop
                Add-AppxPackage -Path "$wingetTemp\$vclibfile" -ErrorAction Stop
                Write-Output "$vclibfile has been installed."
            } else {
                Write-Output "$vclibfile is already installed."
            }
            
            if (-not (Get-AppxPackage -Name "Microsoft.UI.Xaml.2.8")) {
                Write-Output "$uixamlfile is not installed. Installing..."
                $uixamlDownloadUrl = $uixamlUrl + $uixamlfile
                Invoke-WebRequest -Uri $uixamlDownloadUrl -OutFile "$wingetTemp\$uixamlfile" -ErrorAction Stop
                Add-AppxPackage -Path "$wingetTemp\$uixamlfile" -ErrorAction Stop
                Write-Output "$uixamlfile has been installed."
            } else {
                Write-Output "$uixamlfile is already installed."
            }
            
            Write-Host "Dependencies have been checked and installed successfully."
        }

        function wgInstall {
            # Download and install the latest version of winget
            Invoke-WebRequest -Uri "https://aka.ms/getwinget" -OutFile "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
            Add-AppxPackage -Path "$wingetTemp\Microsoft.DesktopAppInstaller_8wekyb3d8bbwe.msixbundle" -ErrorAction Stop
            
            Write-Host "winget has been installed successfully."
        }

        # Check if winget is installed
        $wingetInstalled = Get-Command winget -ErrorAction SilentlyContinue
        if ($wingetInstalled) {
            $installedVersion = (winget --version).Trim()
            $wingetReleaseInfo = Invoke-RestMethod -Uri "https://api.github.com/repos/microsoft/winget-cli/releases/latest" -ErrorAction Stop
            $latestVersion = $wingetReleaseInfo.tag_name
        
            if ($installedVersion -ge $latestVersion) {
                Write-Host "winget is already up to date (version $installedVersion). Exiting."
            } else {
                Write-Host "winget is installed but outdated (installed version: $installedVersion, latest version: $latestVersion). Proceeding with the update..."
                wgInstall
            }
        } else {
            Write-Host "winget is not installed. Proceeding with the installation..."
            wgDependencies
        }
    } catch {
        Handle-Error "Failed to check or install winget: $_"
    }

    ######### Perform Windows Update #########
    Write-Host "*************Running Windows OS Updates*************"

    try {
        $windowsUpdateCommand = 'Install-WindowsUpdate -NotCategory "Drivers" -NotTitle "Firmware" -MicrosoftUpdate -AcceptAll -IgnoreReboot -Verbose -Confirm:$false'
        $usoClientCommand = 'Start-Process -FilePath "C:\Windows\System32\UsoClient.exe" -ArgumentList "startinteractivescan" -NoNewWindow -Wait'

        #Invoke-Expression $windowsUpdateCommand -ErrorAction Stop
        Invoke-Expression $usoClientCommand -ErrorAction Stop
    } catch {
        Handle-Error "Failed to perform Windows Update: $_"
    }

    ######### Perform Apps Update #########
    Write-Host "*************Running Apps Updates (Timeout 30mins)*******"

    try {
        # Define the timeout period in seconds
        $timeoutInSeconds = 1800

        # Define the path to the script file
        $scriptPath = "C:\temp\winget_script.ps1"

        # Define the winget command
        $wingetCommand = @"
winget upgrade --accept-package-agreements --accept-source-agreements --all --include-unknown --force --disable-interactivity --verbose --silent
"@

        # Create the winget script file
        $wingetCommand | Set-Content -Path $scriptPath -ErrorAction Stop

        # Start the command asynchronously without opening a new window
        $wingetProcess = Start-Process -FilePath "powershell.exe" -ArgumentList "-File `"$scriptPath`"" -PassThru

        # Wait for the process to finish or timeout
        if ($wingetProcess.WaitForExit($timeoutInSeconds * 1000)) {
            Write-Output "Command completed within $timeoutInSeconds seconds."
        } else {
            Write-Output "Command timed out after $timeoutInSeconds seconds."
            # If the command timed out, try to close the PowerShell window more aggressively
            try {
                # Terminate the PowerShell process forcefully
                Stop-Process -Name "powershell" -Force
                Write-Output "PowerShell process terminated."
            } catch {
                Handle-Error "Failed to terminate the PowerShell process: $_"
            }
        }

        # Delete the winget script file
        Remove-Item -Path $scriptPath -Force -ErrorAction SilentlyContinue

        # Make sure to kill any residual winget processes
        Get-Process -Name "winget" | Stop-Process -Force -ErrorAction SilentlyContinue
    } catch {
        Handle-Error "Failed to perform Apps Update: $_"
    }

    ######### Remove Silverlight #########

    Write-Host "*************Checking for Silverlight*************"

    try {
        # Check if Silverlight is installed
        if (Get-WmiObject -Query "SELECT * FROM Win32_Product WHERE Name LIKE '%Silverlight%'") {
            Write-Host "Silverlight is installed. Removing"
            
            # Uninstall Silverlight
            $uninstallResult = (Uninstall-Package -name 'Microsoft Silverlight' -force)
        } else {
            Write-Host "Silverlight is not installed."
        }
    } catch {
        Handle-Error "Failed to check or remove Silverlight: $_"
    }

    ######### Perform Log4j-Scan #########

    Write-Host "*************Checking log4j*************"

    try {
        # Check if log4j is installed
        # Define variables
        $jar_file = "c:\temp\log4jscan-latest.jar"
        $log_file = "c:\temp\log4j.log"

        # Function to check if JAR file exists
        function Check-JarExistence {
            if (Test-Path $jar_file) {
                Write-Host "JAR file already exists. Skipping download."
                return $true
            } else {
                return $false
            }
        }

        # Check if log4j JAR file exists
        if (Check-JarExistence) {
            Write-Host "Using existing JAR file: $jar_file"
        } else {
            # Get the latest release URL
            $latest_url = (Invoke-WebRequest -Uri "https://api.github.com/repos/logpresso/CVE-2021-44228-Scanner/releases/latest" | ConvertFrom-Json).assets | Where-Object { $_.browser_download_url -like "*.jar" } | Select-Object -ExpandProperty browser_download_url

            # Download the latest .jar file
            Invoke-WebRequest -Uri $latest_url -OutFile $jar_file -ErrorAction Stop

            # Check if download was successful
            if ($?) {
                Write-Host "Downloaded: $jar_file"
            } else {
                Handle-Error "Failed to download JAR file."
                exit 1
            }
        }

        # Run the scanner
        java -jar $jar_file --scan-log4j1 --no-empty-report --force-fix --all-drives > $log_file
        Write-Host "Scan completed. Log file: $log_file"
    } catch {
        Handle-Error "Failed to perform log4j scan: $_"
    }

    ######### Windows Sanity Check Completed #########

} catch {
    Handle-Error "An unexpected error occurred: $_"
} finally {
    # Stop logging
    Stop-Transcript

    # Exit with appropriate status code
    if ($errorOccurred) {
        exit 1
    } else {
        exit 0
    }
}
