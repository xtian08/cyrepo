#!/bin/bash

#: Script should be "ideally" symlinked to PATH
#:  During an update, this will be replaced since it contains
#:  everything needed to install/run/manage our agent

#: Script to centrally manage the agent on multiple distributions
#: Currently supports
#  - systemd via .service (unit) installation
#  - upstart via .conf (job) installation
#  - sysv-init via init.d service shell script
#  - chkconfig via init.d service shell script
#  - macOS via launchctl service control

#: Raw agent is append to end for extraction
#: Single file builder will populate
AGENT_BUILD_VERSION=1663181909
AGENT_SEMANTIC_VERSION=3.1.9.24
AGENT_ARCHIVE_CATALOG=("arm64:30319411:30319410:agent-1663181909.tar.gz")
BOOTSTRAP_SEMANTIC_VERSION=2.4.0.5
PLATFORM_TYPE=darwin
SENSOR_ARCHIVE_CATALOG=()
SENSOR_SEMANTIC_VERSION=0

#: How long should we wait for the service
SERVICE_WAIT_TIME=15
REMOVE_EXISTING="false"

#: local vars
RAPID7_BASE="/opt/rapid7"
BASE_INSTALL="${RAPID7_BASE}/ir_agent"
COMPONENTS_BASE="${BASE_INSTALL}/components"
BOOTSTRAP_COMPONENT_NAME="bootstrap"
AGENT_COMPONENT_NAME="insight_agent"
SENSOR_COMPONENT_NAME="network_sensor"

#: Bootstrap directories
BOOTSTRAP_COMPONENT_DIR="${COMPONENTS_BASE}/${BOOTSTRAP_COMPONENT_NAME}"
BOOTSTRAP_COMPONENT_COMMON="${BOOTSTRAP_COMPONENT_DIR}/common"
BOOTSTRAP_COMPONENT_COMMON_SSL="${BOOTSTRAP_COMPONENT_COMMON}/ssl"
BOOTSTRAP_COMPONENT_VERSION="${BOOTSTRAP_COMPONENT_DIR}/${BOOTSTRAP_SEMANTIC_VERSION}"

#: Agent component directories
AGENT_COMPONENT_DIR="${COMPONENTS_BASE}/${AGENT_COMPONENT_NAME}"
AGENT_COMPONENT_COMMON="${AGENT_COMPONENT_DIR}/common"
AGENT_COMPONENT_VERSION="${AGENT_COMPONENT_DIR}/${AGENT_SEMANTIC_VERSION}"

#: Sensor component directories
SENSOR_COMPONENT_DIR="${COMPONENTS_BASE}/${SENSOR_COMPONENT_NAME}"
SENSOR_COMPONENT_COMMON="${SENSOR_COMPONENT_DIR}/common"
SENSOR_COMPONENT_VERSION="${SENSOR_COMPONENT_DIR}/${SENSOR_SEMANTIC_VERSION}"

#: Directories that need to be built
INSTALL_DIRS=(${BOOTSTRAP_COMPONENT_COMMON} ${BOOTSTRAP_COMPONENT_COMMON_SSL} ${BOOTSTRAP_COMPONENT_VERSION} ${AGENT_COMPONENT_COMMON} ${AGENT_COMPONENT_VERSION})

AGENT_SERVICE_NAME="ir_agent"
AGENT_SERVICE_SCRIPT="ir_agent_service.sh"
AGENT_PID_FILE="/var/run/com.rapid7.ir_agent.pid"
AGENT_GZTAR_NAME="agent-${AGENT_BUILD_VERSION}".tar.gz

CURRENT_FP=`dirname "$0"`
AGENT_EXE="ir_agent"
APPBIN="/opt/rapid7/ir_agent/${AGENT_EXE}"

#: Required files for installation - should be right next to agent_control.sh
CERTS=(cafile.pem client.crt  client.key)
BOOTSTRAP_FILENAME="bootstrap"
#: Optional files for installation - should be right next to agent_control.sh
OPTIONAL_BOOTSTRAP_COMMON_FILES=(proxy.config)

#: systemd
SYSTEMD_UNIT="ir_agent.service"
SYSTEMD_START="systemctl start ${SYSTEMD_UNIT}"
SYSTEMD_STOP="systemctl stop ${SYSTEMD_UNIT}"
SYSTEMD_STATUS="systemctl status ${SYSTEMD_UNIT}"
SYSTEMD_RELOAD="systemctl daemon-reload"
SYSTEMD_ENABLE="systemctl enable ${SYSTEMD_UNIT}"

#: upstart
SERVICE_STOP="service ${AGENT_SERVICE_NAME} stop"
SERVICE_START="service ${AGENT_SERVICE_NAME} start"
SERVICE_STATUS="service ${AGENT_SERVICE_NAME} status"
UPSTART_CONF="ir_agent.conf"

#: sysvinit
SYSV_SCRIPT="ir_agent_sysv.sh"

#: chkconfig
CHKCONFIG_SCRIPT="ir_agent_chkconfig.sh"

#: lsbconfig
LSBCONFIG_SCRIPT="ir_agent_lsb.sh"

#: macOS
MACOS_SVC_ROOT="/Library/LaunchDaemons"
MACOS_SVC="com.rapid7.ir_agent"
MACOS_CONF="com.rapid7.ir_agent.plist"
MACOS_STATUS="launchctl list ${MACOS_SVC}"
MACOS_START="launchctl start ${MACOS_SVC}"
MACOS_STOP="launchctl stop ${MACOS_SVC}"
MACOS_LOAD="launchctl load -w ${MACOS_SVC_ROOT}/${MACOS_CONF}"
MACOS_UNLOAD="launchctl unload -w ${MACOS_SVC_ROOT}/${MACOS_CONF}"

USAGE="
-- Install options --
    install         - Extracts zip, makes necessary directories and installs agent as a service
                      (See install_start options)
    install_start   - Runs install and immediately starts service
                      Optional flags:
                      --attributes  : Custom attributes may be used to identify and group
                                      Insight Agents in ways that are meaningful to your
                                      organization.  Use commas to specify multiple
                                      attributes.  Example: script.sh install
                                      --attributes=\"lab_system, managed, commercial\"
                      --config_path : Supply a path to the configuration files if already
                                      downloaded or where they should be downloaded if using
                                      a token
                      --token       : Supply a token generated by the server in place of
                                      the config files
                      --https-proxy : Supply an HTTPS proxy for the Insight Agent to use when communicating with the
                                      Insight Platform.  Example: --https-proxy=example.rapid7.com:3128, with credentials
                                      --https-proxy=<username>:<password>@example.rapid7.com:3128
    uninstall       - Removes, un-registers and deletes agent files
    reinstall       - Combines uninstall and install
    reinstall_start - Combines uninstall and install_start
-- Service options --
    start      - Starts the agent service
    stop       - Stops the agent service
    status     - Show the current status of the agent process by using the service controller
    raw_status - Show the current status by manually interrogating the pid and lock file
-- Misc options --
    version    - Shows the agent version bundled with the installer
    extract    - Extracts the embedded agent zip to the /tmp directory (debugging)
                 <destination_path> - path to extract agent archive to (i.e /tmp)
                 "

#: Mimic codes
GREEN='\e[0;32m'
CYAN='\e[0;36m'
YELLOW='\e[1;33m'
RED='\e[0;31m'
NC='\e[0m' # No Color

ERROR_SIG="[${RED}ERROR${NC}]"
INFO_SIG="[${GREEN}INFO${NC}]"
STOPPED_SIG="[${YELLOW}STOPPED${NC}]"
SUCCESS_SIG="[${CYAN}SUCCESS${NC}]"

#: Helper functions
usage() {
    echo "Usage: $0 <command>"
    echo "${USAGE}"
    exit 1
}

error_msg() {
    strlen=${#1}
    cols=$((`tput cols` - $strlen))
    printf "%${strlen}s %${cols}b\n" "$1" ${ERROR_SIG}
}

info_msg() {
    strlen=${#1}
    cols=$((`tput cols` - $strlen))
    printf "%${strlen}s %${cols}b\n" "$1" ${INFO_SIG}
}

stopped_msg() {
    strlen=${#1}
    cols=$((`tput cols` - $strlen))
    printf "%${strlen}s %${cols}b\n" "$1" ${STOPPED_SIG}
}

success_msg() {
    strlen=${#1}
    cols=$((`tput cols` - $strlen))
    printf "%${strlen}s %${cols}b\n" "$1" ${SUCCESS_SIG}
}

fail_out(){
    error_msg "$@"
    remove_agent_base
    exit 1
}

#: Cleans up any processes that are watching for service
#:   start/stop to return when a user does ctrl+c
proc_cleanup() {
    info_msg "Caught signal $1 - Running cleanup"
    kill -TERM -- -$$ >/dev/null 2>&1 #: kills anything this shell was running
    wait $! >/dev/null 2>&1
    info_msg "Cleanup completed!"
    exit 1
}

_mktemp() {
    if is_macos ; then
        #: mac 10.10 requires a template prefix
        mktemp -t agent $*
    else
        mktemp $*
    fi
    return $?
}

_tail_bytes() {
    #: A defect in the implementation of tail on openSUSE 11 prevents us from
    #: combining '-c +N' with stdin. Therefore, we must use '--bytes=+N'.
    #: However, '--bytes' is not supported on macOS, so we must continue to use '-c +N'.
    if is_macos ; then
        tail -c $@
    else
        tail --bytes=$@
    fi
}

#: handler on all sigs so we always cleanup if we are in the middle
#:  of waiting for a service to complete and get signal.
trap proc_cleanup SIGHUP SIGINT

#: Shows some spinning status while the script is doing/waiting something
status_marker() {
    #: quick notify on timeout based on sig
    while true
    do
        printf "."
        printf -- "-%.0s"
        sleep 0.10

        printf -- "\b \b\b%.0b"
        printf -- "\\%.0s"
        sleep 0.10

        printf -- "\b%.0s"
        printf -- "|%.0s"
        sleep 0.10

        printf -- "\b%.0s"
        printf -- "/%.0s"
        sleep 0.10

        printf -- "\b%.0s"
        printf -- "."
    done
}

#: A func to execute a provided command and use pid_watcher to monitor.
#: $1 - Cmd
#: $2 - Msg
cmd_watcher(){
    #: Background the command for monitoring
    logfile=$(_mktemp)
    $1 > $logfile 2>&1 &
    local wcmd=$!
    pid_watcher ${wcmd} $2
    local rwatch=$?

    #: what was the watcher return
    if [ $rwatch -ne 0 ]; then
        error_msg "Request timed out"
        return $rwatch #: returns the signum
    fi

    #: Now check the subproc exit code
    wait ${wcmd}
    rproc=$?

    cat $logfile
    rm $logfile
    return $rproc
}

#: A func to show a status instead of looking like the script is frozen while its waiting
#:  for the service to start. Don't want to user thinking its stuck and hitting ctrl+c
#:  and stopping the installation prematurely
#: $1 - pid to wait on
#: $2 - msg about what we are waiting on to complete
pid_watcher() {

    info_msg "Checking on status: $2"
    #: Start the marker trace so the user can see a status instead of thinking its frozen
    #:  and hit ctrl+c killing the installer before its done.
    status_marker &
    local _stat_pid=$!
    local _time=0
    local _ret=0
    sleep 1 #: give the proc a moment to start and initialize the daemon

    #: if the pid is still running - keep tickin showing we are still waiting, not frozen
    while kill -0 $1 >/dev/null 2>&1
    do
        if [ ${_time} -gt ${SERVICE_WAIT_TIME} ]
        then
            #: timeout - stop the status ticker
            kill -TERM ${_stat_pid}
            wait $! >/dev/null 2>&1
            echo -e "\r-- timed out --"
            kill -TERM -- -$$ #: kills any status stuff running from the procsub to be safe based on this PGID (e.g centOS)
            wait $1 2>/dev/null  #: don't want to see any jobStatus's

            _ret=$?
            return ${_ret} #: took to long SIGTERM'd
        else
            _time=$(expr ${_time} + 1)
            sleep 1
        fi
    done

    #: Good, it completed before the timeout - return it exit status
    kill -TERM ${_stat_pid}
    wait $! 2>/dev/null #: junk the output
    echo -e "\r-- completed --"
    return ${_ret}
}

unsupported_message() {
    info_msg 'Verify that one of the below startup services are available'
    info_msg 'systemd: --> which systemctl && ls /etc/systemd/system/*.wants'
    info_msg 'upstart: --> /sbin/upstart* && ls /etc/init/*.conf'
    info_msg 'sysvinit: --> which update-rc.d'
    info_msg 'chkconfig: --> which chkconfig && ls /etc/init.d/functions'
    info_msg 'lsbconfig: --> ls /lib/lsb/init-functions && ls /etc/rc.status'
}

is_supported_distro() {
    #: Ensure the installer can only execute on intended platform
    ( ! is_macos && [ "${PLATFORM_TYPE}" == "darwin" ]) || ( is_macos && [ "${PLATFORM_TYPE}" != "darwin" ]) && return 1
    #: Ensure the installer can only execute on known platforms
    ( is_macos || is_upstart || is_systemd || is_sysvinit || is_chkconfig || is_lsbconfig ) && return 0
    #: Not supported distro
    info_msg 'Could not find any supported startup services(systemd | upstart | sysvinit | chkconfig | lsbconfig)' && unsupported_message
    return 1
}

is_agent_installed() {
    if [ -d ${BASE_INSTALL} ]
    then
        info_msg "Agent install directory exists"
        if [ -n "$(ls -A ${BASE_INSTALL})" ]
        then
            info_msg "Agent directory has contents"
            return 0
        else
            info_msg "Agent directory is empty"
        fi
    fi
    return 1
}

check_running_agent() {
    pid=`pgrep -f ${APPBIN}`
    [ $? -eq 0 ] && return 0
    return 1
}

handle_args(){

  #: The first argument is the operation being performed (e.g. install, uninstall, or reinstall).
  local _op=$1
  shift

  #: 2.x agents read a cached agent ID from bootstrap.cfg - by reusing this file, we can reuse previous agent ID.
  if [ "$_op" == "reinstall" ] || [ "$_op" == "reinstall_start" ]; then
      REUSE_BOOTSTRAP_CFG=true
  fi

  # As long as there is at least one more argument, keep looping
  while [[ $# -gt 0 ]]; do
      local _key="$1"
      case "${_key}" in
          -t|--token)
            shift
            TOKEN="$1"
          ;;
            -t=*|--token=*)
            TOKEN="${key#*=}"
          ;;
          -a|--attributes)
            shift
            ATTRIBUTES="$1"
          ;;
          -a=*|--attributes=*)
            ATTRIBUTES="${_key#*=}"
          ;;
          -p|--https-proxy)
            shift
            HTTPS_PROXY="$1"
          ;;
          -p=*|--https-proxy=*)
            HTTPS_PROXY="${_key#*=}"
          ;;
          -c|--config_path)
            shift
            CURRENT_FP="$1"
          ;;
            -c=*|--config_path=*)
            CURRENT_FP="${key#*=}"
          ;;
          *)
            # Error on unknown options
            fail_out "Unknown option '${_key}'"
          ;;
      esac

      # Shift after checking all the cases to get the next option
      shift
  done
}

parse_input(){

  #: Parse any custom attributes provided at install time (used to build attributes.json).
  if [ ! -z "${ATTRIBUTES}" ]; then

    #: check if attributes is less than our max length limit
    local _attr_max_length=2049
    local _attr_length_error="Attributes must be ${_attr_max_length} characters or less in length"
    local _charlen=${#ATTRIBUTES}
    [[ "${_charlen}" -lt "${_attr_max_length}" ]] || fail_out "${_attr_length_error}"

    #: check if attributes are valid (Allowed chars: A-Z,a-z,0-9,_,-,=)
    local _attr_syntax_error="Attributes may only contain upper and lower case letters (A-Z, a-z), numbers (0-9), underscores (_), dashes (-), equal signs (=), and commas (,)."
    local _pattern='(^[a-zA-Z0-9_=, \\-]+$)'
    [[ ${ATTRIBUTES} =~ ${_pattern} ]] || fail_out "${_attr_syntax_error}"
  fi

  #: Parse the HTTPS proxy configuration provided at install time if applicable (used to build proxy.config).
    if [ ! -z "${HTTPS_PROXY}" ]; then

        #: Ensure that the provided HTTPS proxy configuration does not exceed the maximum length of a DNS name + port.
        #: - HTTPS protocol prefix (i.e. https://)                                                         (8)
        #: - TCP/IP port suffix:   (e.g. :65535)                                                           (6)
        #: - DNS names have a maximum length of 255 octets (RFC 1035 section 2.3.4): (63).(63).(63).(62) = (255)
        #: - IPv6 addresses have a maximum length of 39 characters.                                        (39)
        #: - IPv4-mapped IPv6 addresses have a maximum length of 22 characters.                            (22)
        #:
        #: Therefore, the maximum length should be: (8 + 255 + 6) + 1 = 270
        local _https_proxy_max_length=270
        local _https_proxy_max_length_error="HTTPS proxy configuration must be ${_https_proxy_max_length} characters or less in length"
        local _charlen=${#HTTPS_PROXY}
        [[ "${_charlen}" -lt "${_https_proxy_max_length}" ]] || fail_out "${_https_proxy_max_length_error}"
  fi

}

#####################
### OSX Functions ###
#####################

is_macos() {
    which launchctl >/dev/null 2>&1
    [ $? -eq 0 ] && return 0
    return 1
}

svc_install_macos() {
    info_msg "Installing macOS service"
    cp ${AGENT_COMPONENT_VERSION}/${MACOS_CONF} ${MACOS_SVC_ROOT}
    ! ( ${MACOS_LOAD} ) && fail_out "Unable to load config"
    chmod 644 ${MACOS_SVC_ROOT}/${MACOS_CONF}

}

svc_remove_macos() {
    info_msg "Removing macOS configuration"
    ${MACOS_UNLOAD} >/dev/null 2>&1
    [ -f ${MACOS_SVC_ROOT}/${MACOS_CONF} ] && rm ${MACOS_SVC_ROOT}/${MACOS_CONF}
    return 0
}

svc_stop_macos() {
    cmd_watcher "${MACOS_STOP}" "macOS service stop"
    return $?
}

svc_start_macos() {
    cmd_watcher "${MACOS_START}" "macOS service start"
    return $?
}

svc_status_macos(){
    cmd_watcher "${MACOS_STATUS}" "macOS service status" "q"
    return $?
}

#########################
### Systemd Functions ###
#########################

is_systemd() {
    which systemctl >/dev/null 2>&1 && ls /etc/systemd/system/*.wants >/dev/null 2>&1
    [ $? -eq 0 ] && return 0
    return 1
}

svc_install_systemd() {
    info_msg "Installing systemd service"

    ! ( cp -f ${AGENT_COMPONENT_VERSION}/${SYSTEMD_UNIT} /etc/systemd/system/${SYSTEMD_UNIT} ) && fail_out "Unable to copy systemd config file"
    chmod 644 /etc/systemd/system/${SYSTEMD_UNIT}

    ${SYSTEMD_RELOAD} 2>&1
    ${SYSTEMD_ENABLE} 2>&1
    return $?
}

svc_start_systemd() {
    cmd_watcher "${SYSTEMD_START}" "systemd service start"
    _ret=$?
    [ ${_ret} -eq 0 ] && info_msg "Started ir_agent via systemctl" && return 0
    return ${_ret}
}

svc_remove_systemd() {
    info_msg "Removing systemd service"
    systemctl disable ${AGENT_EXE} >/dev/null 2>&1
    return 0
}

#: Have to print here cause systemctl returns no status via stdout
#: $1 -
svc_status_systemd(){
    cmd_watcher "${SYSTEMD_STATUS}" "systemd service status" "q"
    local _ret=$?

    if [ -n "$1" ];
    then
        #: good run
        if [ ${_ret} -eq 0 ]
        then
            success_msg "Agent running"

        #: cmd returned err
        elif [ ${_ret} -eq 1 ]
        then
            stopped_msg "Agent not running"

        #: Signaled ran too long..
        else
            error_msg "Unable to get service status"
        fi
    fi
    return ${_ret}
}

###########################
### lsbconfig Functions ###
###########################

is_lsbconfig() {
    [ -e /lib/lsb/init-functions ] && [ -e /etc/rc.status ] && return 0
    return 1
}

svc_install_lsbconfig() {
    info_msg "Installing lsbconfig service"
    ! ( cp -f ${AGENT_COMPONENT_VERSION}/${LSBCONFIG_SCRIPT} /etc/init.d/${AGENT_SERVICE_NAME} ) && fail_out "Unable to copy lsb config file"
    chmod 755 /etc/init.d/${AGENT_SERVICE_NAME}
    chkconfig --add ${AGENT_SERVICE_NAME}
    chkconfig --level 12345 ir_agent on
}

svc_remove_lsbconfig() {
    info_msg "Removing lsbconfig configuration"
    rm /etc/init.d/${AGENT_SERVICE_NAME} >/dev/null 2>&1
    rm /etc/init.d/${AGENT_SERVICE_NAME} >/dev/null 2>&1
    rm /var/log/ir_agent.log >/dev/null 2>&1
    rm /var/log/ir_agent_test.log >/dev/null 2>&1
    return 0
}

svc_start_lsbconfig() {
    cmd_watcher "${SERVICE_START}" "lsb service start"
    return $?
}

svc_status_lsbconfig(){
    cmd_watcher "${SERVICE_STATUS}" "lsb service start" "q"
    _ret=$?
    [ ${_ret} -eq 0 ] && svc_raw_status && return 0
    error_msg "Agent not running"
    return $?
}

#########################
### Upstart Functions ###
#########################

is_upstart() {
    ls /sbin/upstart* >/dev/null 2>&1 && ls /etc/init/*.conf >/dev/null 2>&1
    [ $? -eq 0 ] && return 0
    return 1
}

svc_install_upstart() {
    info_msg "Installing upstart service"
    ! ( cp -f ${AGENT_COMPONENT_VERSION}/${UPSTART_CONF} /etc/init/${UPSTART_CONF} ) && fail_out "Unable to copy lsb config file"
    chmod 644 /etc/init/${UPSTART_CONF}
}

svc_remove_upstart() {
    info_msg "Removing upstart configuration"
    rm /etc/init/${UPSTART_CONF} >/dev/null 2>&1
    return 0
}

svc_start_upstart() {
    cmd_watcher "${SERVICE_START}" "upstart service start"
    return $?
}

svc_status_upstart(){
    cmd_watcher "${SERVICE_START}" "upstart service status" "q"
    return $?
}

#########################
## chkconfig Functions ##
#########################

is_chkconfig() {
    which chkconfig >/dev/null 2>&1 &&  [ -e /etc/init.d/functions ]
    [ $? -eq 0 ] && return 0
    return 1
}

svc_install_chkconfig() {
    info_msg "Installing chkconfig script"
    ! ( cp -f ${AGENT_COMPONENT_VERSION}/${CHKCONFIG_SCRIPT} /etc/init.d/${AGENT_SERVICE_NAME} ) && fail_out "Unable to copy lsb config file"
    chmod 755 /etc/init.d/${AGENT_SERVICE_NAME}
    chkconfig --add ${AGENT_SERVICE_NAME}
    chkconfig --level 12345 ir_agent on
    return 0
}

svc_remove_chkconfig() {
    info_msg "Removing agent from chkconfig"
    chkconfig --del ${AGENT_SERVICE_NAME} >/dev/null 2>&1
    rm /etc/init.d/${AGENT_SERVICE_NAME} >/dev/null 2>&1
    rm /var/log/ir_agent.log >/dev/null 2>&1
    rm /var/log/ir_agent_test.log >/dev/null 2>&1
    return 0
}

svc_start_chkconfig() {
    cmd_watcher "${SERVICE_START}" "chkconfig service start"
    return $?
}

svc_status_chkconfig(){
    cmd_watcher "${SERVICE_STATUS}" "chkconfig service status" "q"
    return $?
}

##########################
### SysvInit Functions ###
##########################

is_sysvinit() {
    which update-rc.d >/dev/null 2>&1
    [ $? -eq 0 ] && return 0
    return 1
}

svc_install_sysvinit() {
    info_msg "Installing sysvinit script"
    ! ( cp -f ${AGENT_COMPONENT_VERSION}/${SYSV_SCRIPT} /etc/init.d/${AGENT_SERVICE_NAME} ) && fail_out "Unable to copy lsb config file"
    chmod 755 /etc/init.d/${AGENT_SERVICE_NAME}
    update-rc.d ${AGENT_SERVICE_NAME} start 98 1 2 3 4 5 . stop 98 0 6 .
    return 0
}

svc_remove_sysvinit() {
    info_msg "${INFO_SIG}`update-rc.d -f ${AGENT_SERVICE_NAME} remove`"
    rm /etc/init.d/${AGENT_SERVICE_NAME} >/dev/null 2>&1
    rm /var/log/ir_agent.log >/dev/null 2>&1
    rm /var/log/ir_agent_test.log >/dev/null 2>&1
    return 0
}

svc_start_sysvinit() {
    cmd_watcher "${SERVICE_START}" "sysvinit service start"
    return $?
}

svc_status_sysvinit(){
    cmd_watcher "${SERVICE_STATUS}" "sysvinit service status" "q"
    return $?
}

########################
### Script Functions ###
########################

svc_install() {
    is_macos && svc_install_macos && return 0
    is_systemd && svc_install_systemd && return 0
    is_upstart && svc_install_upstart && return 0
    is_sysvinit && svc_install_sysvinit && return 0
    is_chkconfig && svc_install_chkconfig && return 0
    is_lsbconfig && svc_install_lsbconfig && return 0
    return 1
}

check_pkg_deps() {

    info_msg "Checking installer dependencies"

    #: Check for configuration file
    [ ! -e "${CURRENT_FP}/config.json" ] && fail_out "Unable to find agent config.json. This file was included in the distribution zip file and is required for installation."

    #: Check for the necessary SSL files
    for cert in ${CERTS[@]}
    do
        [ ! -e "${CURRENT_FP}/$cert" ] && fail_out "Unable to find required ${cert}. This file was included in the distribution zip file and is required for installation."
    done
}

is_supported_sensor_kernel_name() {
    KERNEL=`uname -s`
    [ "$KERNEL" == "Linux" ] && return 0
    error_msg "Incompatible kernel: $KERNEL"
    return 1
}

is_supported_sensor_kernel_version() {
    # https://github.com/opencontainers/runc/blob/master/libcontainer/SPEC.md
    MIN_KERNEL_VERSION='3.10'
    VERSION=`uname -r`
    # Match on Kernel Version.Marjor Revision   Ignore Minor Revision
    if [[ "$VERSION" =~ ^([0-9]{1,2}\.[0-9]{1,3})(.*)$ ]]; then
        LOWEST=$(echo -e $MIN_KERNEL_VERSION"\n"${BASH_REMATCH[1]}|sort -V|head -n 1)
        [ $LOWEST == $MIN_KERNEL_VERSION ]  && return 0
    fi
    error_msg "Incompatible kernel version: $VERSION The minumum supported version is : $MIN_KERNEL_VERSION"
    return 1
}

is_supported_sensor_CPU() {
    # Look in /proc/cpuinfo to see if all required CPU flags are present
    local required_flags all_flags missing_flags cpu_model has_flag
    local cpuinfo=/proc/cpuinfo
    if ! [ -e "$cpuinfo" ]; then
        error_msg "The network sensor runs only on Linux systems"
        return 1
    fi
    required_flags="ssse3 sse4_2 pclmulqdq popcnt"
    all_flags=$(sed -Ene "/^flags[[:space:]]*:/{s/^[^:]*://;p;q}" $cpuinfo)
    declare -A has_flag
    for f in $all_flags; do has_flag["$f"]=1; done
     missing_flags=''
    for f in $required_flags; do
        [ "${has_flag[$f]}" ] || missing_flags="$missing_flags $f"
    done
    if [ "$missing_flags" ]; then
        cpu_model=$(
        sed -Ene "/^model name[[:space:]]*:/{s/^[^:]*://;p;q}" $cpuinfo)
        error_msg "Incompatible CPU: $cpu_model, missing $missing_flags"
        return 1
    fi

    return 0
}

is_cgroup_mounted() {
    awk '
        $3=="cgroup"  && $2=="/sys/fs/cgroup/devices" { print $3 }
        $3=="cgroup2" && $2=="/sys/fs/cgroup"         { print $3 }
    ' /proc/mounts | grep -qE .
}

check_sensor_requirements() {

    is_supported_sensor_kernel_name || fail_out "The kernel is not supported by network sensor" 

    is_supported_sensor_kernel_version || fail_out "The kernel version is not supported by network sensor"

    is_supported_sensor_CPU || fail_out "The CPU is not supported by network sensor"

    is_cgroup_mounted || fail_out "This OS version lacks cgroup support"
}

sensor_reminder() {
  if [ "${sensor_installer}" ]; then
    echo "============================================================================================"
    info_msg "Please login to insight.rapid7.com to select the capture interface and configure the sensor"
    echo "============================================================================================"
  fi
}

check_uid() {
    if [[ $(id -u) -ne 0 ]] ; then echo "Please run as root" ; exit 1 ; fi
}

#: Finds the embedded image in the shell catalog and extracts to location specified
#: $1 - Destination directory path for extraction
#: $2 (optional) - Just dump the archive, don't extract it (for testing/debugging the archive typically)
find_and_extract(){

    local _dist_path="$1"
    local _archive_catalog="$2[@]"
    local _a=(${!_archive_catalog})
    local _dump_archive="$3"
    local _plat=`uname -m`

    #: check that the dest path exists
    [ ! -d "${_dist_path}" ] && fail_out "Must specify a destination path to extract the embedded agent"

    #: Find the image deets and extact them accordingly
    for archive in ${_a[@]}
    do
        local _value="${archive#*:}"
        local _key="${archive%:${_value}}"
        local _gztar_name="${_value##*:}"
        local _location="${_value%:${_gztar_name}}"

        info_msg "Attempting to load ${_plat} archive from catalog"
        if [ "${_plat}" == "${_key}" ]
        then
            END_OFF="${_location#*:}"
            START_OFF="${_location%:${END_OFF}}"

            #: Just carve out the archive and drop in destination directory
            if ( ${_dump_archive} )
            then
                info_msg "Extracting embedded ${_gztar_name} --> ${_dist_path}/${_gztar_name}"
                _tail_bytes -${START_OFF} $0 | _tail_bytes +0 | head -c +${END_OFF} > ${_dist_path}/${_gztar_name}

            #: Extraction for installation
            else
                info_msg "Installing embedded ${_gztar_name} to --> ${_dist_path}"
                _tail_bytes -${START_OFF} $0 | _tail_bytes +0 | head -c +${END_OFF} | tar xz -C ${_dist_path} >/dev/null 2>&1
            fi
            [ $? -ne 0 ] && fail_out "Error extracting image"

            REMOVE_EXISTING="true"
            info_msg "Successfully extracted image"
        fi
    done
}

#: Setup the component links like we do for windows - keep it all the same!
setup_component_links() {

    info_msg "Setup symlink for insight agent component"

    #: insight_agent_comp_dir/insight_agent -> insight_agent_version_dir/ir_agent
    ! ( ln -s "${AGENT_COMPONENT_VERSION}/${AGENT_EXE}" "${AGENT_COMPONENT_DIR}/${AGENT_COMPONENT_NAME}" ) && fail_out "Failed to create insight agent comp link"


    if [ "${SENSOR_SEMANTIC_VERSION}" != "0" ] && [ ! ${#SENSOR_ARCHIVE_CATALOG[@]} -eq 0 ]; then
        info_msg "Setup symlink for network sensor component"
        ! ( ln -s "${SENSOR_COMPONENT_VERSION}/${SENSOR_COMPONENT_NAME}.sh" "${SENSOR_COMPONENT_DIR}/${SENSOR_COMPONENT_NAME}" ) && fail_out "Failed to create network sensor comp link"
    fi
}

install() {

    #: Check for unzip command
    info_msg "Checking for dependencies"
    which tar >/dev/null 2>&1
    [ $? -ne 0 ] && fail_out "Please install tar to continue to properly extract image"

    #: check if both distros found
    ( ! is_supported_distro ) && fail_out "Unsupported distribution detected"

    if [ "${SENSOR_SEMANTIC_VERSION}" != "0" ] && [ ! ${#SENSOR_ARCHIVE_CATALOG[@]} -eq 0 ]; then
        sensor_installer=yes
    fi

    if [ "$sensor_installer" ]; then
        check_sensor_requirements
    fi

    #: check if agent is already installed
    is_agent_installed && fail_out "Insight Agent already installed, please uninstall and try again"

    #: Parse the input data (if any)
    parse_input

    #: If an installation token was not provided, check to see if the required files were provided.
    #: - config.json: defines how to talk to the platform, and what the agent should do when it starts up.
    #: - cafile.pem, client.crt, client.key: required to establish a TLS encrypted connection to the platform.
    if [ -z "$TOKEN" ]
    then
        check_pkg_deps

    #: If an installation token was provided, we're going to use the token handler to obtain config. files.
    else

      # Ensure we can write to current working directory
      if [ ! -w ${CURRENT_FP} ]; then
        CURRENT_FP=${TMPDIR:-$(_mktemp -d)}
        info_msg "Unable to write to the current working directory, using ${CURRENT_FP} instead."
      fi

      #: Extract the installer tarball but only unpack the token_handler
      find_and_extract ${CURRENT_FP} AGENT_ARCHIVE_CATALOG true
      tar -zxf ${CURRENT_FP}/${AGENT_GZTAR_NAME} -C ${CURRENT_FP} "./token_handler" > /dev/null 2>&1
      if [ ! -x "${CURRENT_FP}/token_handler" ]; then
        fail_out "Failed to extract the token handler."
      fi

      if [ -z "$HTTPS_PROXY" ]
      then
        #: Use the token handler to request config files from the API
        RESULT=`${CURRENT_FP}/token_handler -token "${TOKEN}" -filepath ${CURRENT_FP}`
      #: Proxy address is provided
      else
        RESULT=`${CURRENT_FP}/token_handler -token "${TOKEN}" -filepath ${CURRENT_FP} -https-proxy "${HTTPS_PROXY}"`
      fi

      if [ $? -ne 0 ]; then
        error_msg "$RESULT"
        fail_out "Unable to use token to request configuration files."
      fi

      #: Cleanup files we no longer need
      rm ${CURRENT_FP}/${AGENT_GZTAR_NAME} ${CURRENT_FP}/token_handler > /dev/null
    fi

    if [ "${sensor_installer}" ] ; then
        INSTALL_DIRS+=(${SENSOR_COMPONENT_COMMON} ${SENSOR_COMPONENT_VERSION})
    fi

    #: Build component directories
    for idir in ${INSTALL_DIRS[@]}
    do
        info_msg "Building directory: ${idir}"
        ! ( mkdir -p ${idir} ) && fail_out "Unable to create directory"
    done

    #: If an HTTPS proxy configuration was provided, write HTTPS configuration file (i.e. proxy.config).
    #: - Example: { "https": "example.rapid7.com:3128" }
    if [ ! -z "${HTTPS_PROXY}" ]; then
        local HTTPS_PROXY_CONFIGURATION_FILE="${BOOTSTRAP_COMPONENT_COMMON}/proxy.config"

        #: Write the HTTPS proxy configuration to the bootstrap common directory.
        info_msg "Writing HTTPS proxy configuration to ${HTTPS_PROXY_CONFIGURATION_FILE}"
        JSON_ATTRIBUTES="{\"https\": \"${HTTPS_PROXY}\"}"
        echo ${JSON_ATTRIBUTES} > "${HTTPS_PROXY_CONFIGURATION_FILE}"
    fi
